# Claude Agent SDK [Full Workshop] — Thariq Shihipar, Anthropic

## 📹 视频信息

- **频道**: AI Engineer
- **发布日期**: 2026-01-05
- **时长**: 1:52:26
- **原始链接**: [https://www.youtube.com/watch?v=TqC1qOfiVcQ](https://www.youtube.com/watch?v=TqC1qOfiVcQ)

---

# Claude Agent SDK 深度工作坊

本文内容整理自 Anthropic 工程师塔里克·希希帕尔（Thariq Shihipar）在 AI Engineer 频道的技术工作坊。

---

## TL;DR

> Anthropic 的 Claude Agent SDK 通过将 Bash 工具、文件系统和代码生成作为核心能力，重新定义了 AI Agent 开发范式——"Bash is all you need"成为构建强大、灵活且可组合 Agent 的关键洞察，让开发者能专注于解决领域问题而非基础设施。

---

## 📑 章节导航表

| 时间戳 | 章节标题 | 一句话概括 |
|--------|----------|-----------|
| 00:00-07:00 | 开场与 Agent 发展历程 | 从单一 LLM 功能到工作流再到真正的自主 Agent |
| 07:00-15:00 | Claude Agent SDK 架构 | 基于 Claude Code 构建，集成工具、文件系统、技能等完整生态 |
| 15:00-30:00 | Bash is All You Need | Bash 工具是首个"代码模式"，实现动态工具组合 |
| 30:00-40:00 | 工具 vs Bash vs 代码生成 | 三种执行方式的权衡与最佳实践 |
| 40:00-50:00 | Agent 设计循环 | 收集上下文、执行动作、验证工作的三步循环 |
| 50:00-70:00 | 电子表格 Agent 案例分析 | 通过具体案例展示 Agent 设计的创造性思维 |
| 70:00-90:00 | 原型开发实战：宝可梦 Agent | 使用 Claude Code 快速原型开发的完整流程 |
| 90:00-112:00 | Q&A 与最佳实践讨论 | 涵盖安全、扩展性、货币化等实际问题 |

---

## 📊 核心论点

### 1. Agent 是 AI 功能演进的必然阶段

- **核心内容**：AI 功能经历了三个阶段：单一 LLM 功能（如分类任务）→ 工作流（结构化的多步骤任务）→ Agent（自主决策和执行）。Claude Code 作为首个真正的 Agent，能够自主工作 10-30 分钟，根据用户的自然语言指令灵活采取各种行动，标志着 AI 从被动响应转向主动执行的范式转变。
- **关键概念**：自主性、上下文构建、轨迹决策、非结构化任务处理
- **实际意义**：开发者需要从"设计固定流程"的思维转向"提供工具和环境"的思维；企业可以将更多复杂、开放式的任务交给 AI 处理；整个软件开发流程将被重新定义。

### 2. Bash 工具是 Agent 能力的核心基础

- **核心内容**：Bash 不仅仅是执行 shell 命令的工具，而是第一个真正的"代码模式"实现。它允许 Agent 动态存储工具调用结果、生成和执行脚本、组合功能、使用现有软件（如 ffmpeg、LibreOffice）。相比固定的工具集，Bash 提供了无限的灵活性——Agent 可以使用 grep 搜索、npm 管理依赖、git 进行版本控制，而无需为每个功能单独定义工具。
- **关键概念**：动态工具组合、程序化工具调用、上下文工程、Unix 原语
- **实际意义**：极大降低了 Agent 开发的复杂度；避免了"工具爆炸"问题；让 Agent 能够利用整个 Unix 生态系统；使得非编程任务也能通过代码生成方式解决。

### 3. 文件系统作为 Agent 的"工作记忆"

- **核心内容**：文件系统不仅是存储数据的地方，更是 Agent 进行上下文管理和状态维护的核心机制。Agent 可以将中间结果保存为文件、创建草稿本记录思考过程、通过目录结构组织技能和知识。这种方式让 Agent 能够处理远超上下文窗口限制的复杂任务，并实现真正的"渐进式上下文披露"。
- **关键概念**：持久化记忆、状态管理、技能组织、上下文工程
- **实际意义**：解决了长上下文管理问题；使得 Agent 能够处理大规模数据；支持复杂的多步骤任务；为 Agent 间协作提供了基础。

### 4. 三层执行模式的权衡艺术

- **核心内容**：Agent 有三种执行方式：工具（结构化、可靠但上下文占用高）、Bash（可组合、静态脚本、中等延迟）、代码生成（高度灵活、动态脚本但执行时间长）。最佳实践是将工具用于原子操作（如发送邮件）、Bash 用于可组合操作（如搜索和数据处理）、代码生成用于复杂逻辑（如 API 组合和数据分析）。
- **关键概念**：执行模式选择、上下文效率、可组合性、确定性保证
- **实际意义**：开发者需要根据具体场景选择合适的执行方式；不应过度依赖单一模式；混合使用三种方式可获得最佳性能。

### 5. Agent 设计的三步循环模型

- **核心内容**：成功的 Agent 都遵循三步循环：收集上下文（如 grep 查找文件、搜索相关邮件）→ 执行动作（使用工具/Bash/代码生成）→ 验证工作（linting、编译检查、规则验证）。验证步骤尤其关键，它决定了 Agent 的可靠性。编码类任务因有编译和测试步骤而特别适合 Agent；研究类任务则需要通过引用来源等方式进行验证。
- **关键概念**：上下文收集策略、动作执行、确定性验证、错误恢复
- **实际意义**：为 Agent 设计提供了清晰的框架；强调了验证的重要性；帮助评估哪些任务适合用 Agent 解决。

### 6. 技能（Skills）作为知识组织新范式

- **核心内容**：技能本质上是文件系统中的文件夹，包含特定任务的指令、示例和上下文。它们是"渐进式上下文披露"模式的体现——Agent 只在需要时才加载相关技能。例如前端设计技能包含了顶级工程师总结的最佳实践，让 Agent 能够处理分布外的任务。技能市场的出现使得知识共享成为可能。
- **关键概念**：渐进式上下文、领域知识封装、可复用性、技能市场
- **实际意义**：解决了 Agent 处理专业任务的问题；促进了最佳实践的标准化；创造了新的知识共享生态。

### 7. 子 Agent 是复杂任务的关键

- **核心内容**：子 Agent 用于处理需要大量工作但只需返回简单结果的任务，有效管理上下文污染。例如在处理大型电子表格时，主 Agent 可以并行启动多个子 Agent 分别处理不同工作表，然后汇总结果。Claude Agent SDK 提供了业界最好的子 Agent 支持，包括并行执行和竞态条件处理。
- **关键概念**：上下文隔离、并行处理、任务分解、结果汇总
- **实际意义**：使得 Agent 能够处理超大规模任务；提高了执行效率；避免了上下文窗口限制。

### 8. 安全是多层次的系统工程

- **核心内容**：Agent 安全采用"瑞士奶酪"防御模型：模型层对齐（通过强化学习）、框架层权限控制（Bash 命令解析、工具权限管理）、沙箱层隔离（网络和文件系统沙箱）。每一层都有漏洞，但组合起来能提供强大保护。关键是防止"致命三要素"：代码执行、文件系统修改、数据外泄。
- **关键概念**：多层防御、沙箱隔离、权限最小化、确定性规则
- **实际意义**：企业部署 Agent 必须考虑全方位安全；不能依赖单一防御措施；需要在功能和安全之间找到平衡。

### 9. 简单但不容易的设计哲学

- **核心内容**：优秀的 Agent 代码量应该很少（如演示中的 50 行），但需要深刻的洞察。关键是找到将领域问题转化为模型熟悉模式的优雅方式，如将电子表格搜索转化为 SQL 查询。这需要大量实验和迭代，阅读执行记录并不断优化。"模型是培育而非设计出来的"。
- **关键概念**：领域问题转化、分布内知识利用、迭代优化、优雅设计
- **实际意义**：Agent 开发更像艺术而非工程；需要深入理解模型能力；成功的关键在于创造性的问题转化。

### 10. Agent 经济学的新挑战

- **核心内容**：Agent 计算成本高昂，改变了传统 SaaS 经济学——从"一个应用服务百万用户"变为"每个用户一个容器"。货币化策略需要预先设计，建议采用订阅制结合使用量计费。关键是找到真正愿意为 Agent 付费的高价值用户，而非追求用户数量。本地 Agent 应用可能因此复兴。
- **关键概念**：单位经济学、容器化成本、定价策略、高价值用户
- **实际意义**：创业公司需要重新思考商业模式；不能简单复制传统 SaaS 定价；需要在价值和成本间找到平衡。

### 11. 快速迭代是最大竞争优势

- **核心内容**：AI 能力每 6 个月就会发生重大变化，因此"能写代码快 10 倍，就应该扔代码也快 10 倍"。大公司有 6 个月的决策周期，总是在使用过时的 AI 能力。创业公司的优势在于能够立即采用最新能力，不要过度设计系统的"未来兼容性"，而是专注于用当前最佳能力解决问题。
- **关键概念**：技术债务接受、快速原型、能力跟踪、敏捷迭代
- **实际意义**：改变了软件工程的最佳实践；"过度工程"的定义需要更新；持续重构成为常态而非例外。

---

## 🏢 提及的公司/产品

| 公司名 | 讨论语境 | 重要性 |
|--------|----------|--------|
| Anthropic | Claude Agent SDK 开发者，整个工作坊的核心 | ⭐⭐⭐ |
| Claude Code | Agent SDK 的基础，展示了 Agent 能力的最佳实践 | ⭐⭐⭐ |
| Cloudflare/Modal/E2B | Agent 沙箱托管服务提供商 | ⭐⭐ |
| Pokémon/Game Freak | 演示案例中的 API 和数据来源 | ⭐ |
| Smogon | 竞技宝可梦数据平台，展示复杂数据处理 | ⭐ |

---

## 💬 经典金句

> "Bash is all you need."
> — Thariq Shihipar

> "Models are grown, not designed."
> — Thariq Shihipar  

> "We can write code 10 times faster. We should throw out code 10 times faster as well."
> — Thariq Shihipar

> "Simple is not the same as easy."
> — Thariq Shihipar

> "Your agent at the end should be simple, but getting there requires elegance and insight."
> — Thariq Shihipar

---

## 👤 主要人物

### Thariq Shihipar（塔里克·希希帕尔）

**身份**：Anthropic 工程师，Claude Agent SDK 核心开发者
**背景**：在 Anthropic 负责 Agent 框架开发，之前有丰富的 Web 开发经验（提到了 jQuery 到 React 的转变）。对 Agent 设计有深刻理解，强调实践和迭代的重要性。
**核心观点**：Bash 工具是 Agent 最强大的能力；Agent 开发是艺术而非科学；文件系统是上下文管理的关键；安全需要多层防御；快速迭代比完美设计更重要。他将 Agent SDK 比作"Agent 框架中的 React"——虽然有学习曲线，但能带来质的飞跃。

---

## 📺 视频类型判断

**教程示范**：包含大量实战代码演示和架构讲解的技术工作坊

---

## 📝 完整翻译

### (0:00 - 7:00) 开场与 Agent 发展历程
> 从单一 LLM 功能到工作流再到真正的自主 Agent

好的，是的，谢谢加入我的直播。我还在西海岸时间，所以感觉就像我在早上7点做这个分享一样。

很高兴和大家聊聊 Claude Agent SDK。我觉得这会是一个相当粗糙的议程安排，但我们会讨论什么是 Claude Agent SDK？为什么要使用它？现在有这么多其他的 Agent 框架。什么是 Agent？什么是 Agent 框架？

我们会讨论如何使用 Agent SDK 或者通常情况下如何设计一个 Agent。然后我会做一些现场编程，或者说 Claude 会做一些现场编程来原型化一个 Agent。我准备了一些启动代码。

我们今天有两个小时的时间。我们会非常协作，请随时提问。这也不会是一个超级罐头式的演示，我们会现场思考问题。我不会立即有所有的答案。我认为这会是构建 Agent 循环的好方法，这真的很像一种艺术或直觉。

在我们开始之前，我很好奇，举个手，有多少人听说过 Cloud Agent SDK？好的，很棒。太好了。有多少人使用过或试用过？好的，太棒了。

好的，所以举手的人很多。

我先从 Agent 的概述开始。我认为这是人们之前可能见过的东西，但我认为要真正理解 AI 功能是如何演进的，仍然需要一些时间。

当 GPT-3 发布时，它真正关于的是单一 LLM 功能，对吧？比如，"嘿，你能将这个分类并在这些类别中返回响应吗？"然后我们有了更多像工作流程的东西，对吧？"嘿，你能拿这封邮件并给它贴标签吗？"或者"这是我的代码库，通过 RAG 索引。你能给我下一个补全或下一个要编辑的文件吗？"这就是我们称之的工作流程，非常结构化。你说，"嘿，给定这些代码，给我代码输出。"

现在我们来到了 Agent，对吧？使用的典型 Agent 是 Claude Code，对吧？Claude Code 是一个工具，你实际上不需要告诉它什么。我们实际上并不限制它能做什么，对吧？你只是用文本与它对话，它会采取非常广泛的行动，对吧？

所以 Agent 构建自己的上下文，决定自己的轨迹，工作非常非常自主，对吧？我认为随着未来的发展，Agent 会变得越来越自主。我们处在一个可以开始构建这些 Agent 的转折点。它们并不完美，但绝对是开始的正确时机。

Claude Code，我相信你们很多人都试用过或使用过。我认为这是第一个真正的 Agent，对吧？这是我第一次看到 AI 工作 10、20、30 分钟的时候，对吧？所以它是一个编码 Agent。

Claude Agent SDK 实际上是建立在 Claude Code 之上的，我们这样做的原因是基本上我们发现当我们在 Anthropic 构建 Agent 时，我们一直在重复构建相同的部分。为了让你感受一下这是什么样子，当然，他们是模型的起始点，对吧？然后在工具中，你有工具，对吧？这就像第一个明显的步骤，让我们向这个工具中添加一些工具。

稍后，我们也会给出一个例子，说明如何尝试从头开始构建你自己的工具以及那看起来是什么样的，以及那有多么具有挑战性。但工具不仅仅是你自己的自定义工具。可能是与你的文件系统交互的工具，就像 Claude Code 一样。

音量刚刚变大了还是他们拿话筒的距离不够近？[笑声] 好的。无论如何，你有工具，你在循环中运行工具，然后你有提示词，对吧？像核心 Agent 提示词，类似这些的提示词。然后最后你有文件系统，对吧？或者说不是最后，但你有文件系统。文件系统是一种上下文工程的方式，我们稍后会更多讨论，对吧？

### (7:00 - 15:00) Claude Agent SDK 架构
> 基于 Claude Code 构建，集成工具、文件系统、技能等完整生态

我认为我们通过 Claude Code 获得的关键洞察之一是更多地思考上下文，不仅仅是提示词，还有它可以使用的工具、文件和脚本。然后还有技能 (skills)，这是我们最近推出的，如果你们感兴趣的话，我们可以更多地讨论技能。

然后还有像子 Agent、网页搜索、研究压缩、钩子、内存等工具周围的其他东西。这最终会是相当多的内容。所以 Cloud Agent SDK 就是所有这些东西打包给你使用的，对吧？你有你的应用程序。

我认为为了让你感受一下为什么 Cloud Agent SDK 这样，人们已经在 SDK 上构建了大量的 Agent，很多软件 Agent，你知道软件可靠性、安全性、分类、bug 查找、站点和仪表板构建器。

如果这些非常受欢迎。如果你正在使用它，你绝对应该使用 SDK。我想办公 Agent，如果你在做任何类型的办公工作，那里有大量的例子。获得了一些法律、金融、医疗保健的例子。所以有很多人在它之上构建。

我想，好的。所以，为什么选择 Cloud Agent SDK，对吧？我们为什么这样做？为什么我们将它构建在 Claude Code 之上？我们基本上意识到，一旦我们推出 Claude Code，工程师开始使用它，但然后金融人员开始使用它，数据科学人员开始使用它，营销人员开始使用它。

我认为我们意识到人们正在将 Claude Code 用于非编码任务，我们感到当我们构建非编码 Agent 时，我们不断回到它，对吧？我们会更深入地了解为什么这样有效，为什么你可以将 Claude Code 用于非编码任务。剧透一下，这就像 bash 工具。

这是我们看到的一个新兴模式，我们想要使用它，我们已经在其之上构建了我们的 Agent，对吧？这些是我们从部署 Claude Code 中学到的经验，我们已经将其融入其中。所以，工具使用错误或压缩或类似的东西，需要大量规模才能发现的东西，你知道，最佳实践是什么，我们已经将其融入到 Cloud Agent SDK 中。

因此，我们对构建 Agent 的最佳方式有很多强烈的观点。我认为 Cloud Agent SDK 是相当固执己见的。我会谈论其中一些观点以及我们为什么选择它们，对吧？但是，其中一个重要观点是 bash 工具是最强大的 Agent 工具。

好的，我称之为构建 Agent 的 Anthropic 方式，对吧？我不是说你只能使用这种方式的 API 构建 Agent，对吧？但这就像如果你在 Agent SDK 上使用我们固执己见的堆栈，那是什么？对吧？

大致上是 Unix 基元，如 bash 和文件系统，我们将讨论使用 Claude Code 原型化 Agent，我的目标真的是向你展示实时的样子，对吧？为什么 bash 有用？为什么文件系统有用？为什么不只是使用工具？

Agent，我的意思是你也可以制作工作流程，我们稍后会讨论一下，但 Agent 构建自己的上下文，考虑非编码的代码生成。我们使用代码生成来生成文档、查询网络、做数据分析、采取非结构化行动。

对一些人来说，这可能相当违反直觉，同样在原型设计会话中，我们将讨论如何将代码生成用于非编码 Agent。每个 Agent 都有一个容器或在本地托管，因为这是 Claude Code。它需要一个文件系统，它需要 bash，它需要能够在其上操作。所以这是一个非常非常不同的架构。我今天不打算过多讨论架构，但如果这是人们感兴趣的，我们可以在最后讨论，或者抱歉，我指的是托管架构，比如你如何托管 Agent，最佳实践是什么？最后会谈到这个吗？

让我在这里暂停一下，因为我觉得我已经涵盖了很多内容。到目前为止，关于 Agent SDK、Agent，从中你能得到什么，有什么问题吗？

### (15:00 - 30:00) Part 2

### (15:00 - 30:00) Bash is All You Need
> Bash 工具是首个"代码模式"，实现动态工具组合

你对网络进行沙箱化，这是一个很好的方法。如果你在沙箱容器上托管，比如 Cloudflare、Modal 或者你知道的 E2B、Daytona，就像所有这些沙箱提供商一样，他们也在安全方面做了一些级别的工作，对吧？就像你不是在个人电脑上托管它，或者在有你的生产密钥之类的电脑上托管，所以有很多不同的层级，我们可以更深入地讨论托管问题。

好的，我要谈一点"bash 就是一切"的概念。我觉得这是我在 Anthropic 发现的东西。这就像我的主张，你知道吗？我会一直谈论这个，直到每个人都同意我的观点。或者说，这是我们在 Anthropic 发现的东西，我觉得这是我来到这里后发现的。

Bash 是让代码如此优秀的原因，对吧？我觉得你们可能已经看过代码模式或程序化工具使用，就像组合 MLP 的不同方式，Cloudflare 发布了一些博客文章，我们也发布了一些博客文章。我对代码模式的思考方式，或者说 bash，就是它就像第一个代码模式，对吧？所以 bash 工具允许你将工具调用的结果存储到文件中，动态存储内存，生成脚本并调用它们，组合功能比如 tail、graph，它让你使用现有软件，比如 ffmpeg 或 LibreOffice，对吧？

所以 bash 工具可以做很多有趣和强大的事情。再想想是什么让 Claude Code 如此优秀。如果你设计一个代理工具，也许你会有一个搜索工具、一个 lint 工具和一个执行工具，对吧？你有 N 个工具，对吧？每当你想到一个新用例时，你就会说，我现在需要另一个工具，对吧？

相反，现在 Claude 只使用 grep，对吧？它了解你的包管理器。所以它运行像 npm run test.ts 或 index.ts 或其他什么，对吧？它可以进行 lint，对吧？它可以找出你如何进行 lint，对吧？如果你没有 linter，它可以运行 npm run lint。它可以问"如果我为你安装 eslint 怎么样？"，对吧？所以这就像我说的第一个程序化工具调用，第一个代码模式，对吧？你可以非常通用地执行许多不同的操作，对吧？

让我在非编码代理的背景下谈论这个问题，对吧？假设我们有一个邮件代理，用户说"好的，我这周在拼车上花了多少钱？"它通常有一个工具调用，或者通常它有搜索收件箱的能力，对吧？所以它可以运行一个查询，比如"嘿，搜索 Uber 或 Lyft"，对吧？

没有 bash 的话，它搜索 Uber 或 Lyft，得到大约一百封邮件或其他什么，现在它只能思考这些。你知道我的意思吗？我觉得一个很好的类比是，想象如果有人拿着一堆纸来找你，说"嘿，我这周在拼车上花了多少钱？你能读一遍我的邮件吗？"你知道我的意思吧？那会非常困难，对吧？你需要非常非常好的精确度和召回率来做到这一点。

或者用 bash，对吧？假设有一个 Gmail 搜索脚本，对吧？它接受一个查询函数。然后你可以开始将该查询函数保存到文件中或通过管道传输。你可以用 grep 搜索价格。你知道，你可以然后把它们加在一起。你也可以检查你的工作，对吧？比如你可以说，好的，让我抓取我所有的价格，将它们存储在一个带行号的文件中，然后让我能够在之后检查，比如这实际上是一个价格吗？每一个对应什么？对吧？

所以用 bash 工具，你可以做更多动态信息来检查你的工作。这只是一个简单的例子，但希望能向你展示 bash 可组合性的力量，对吧？我在这里暂停一下，关于"bash 就是一切"、bash 工具有任何问题吗？有什么我可以让它更清楚一点的吗？

主持人：你有关于 yolo 模式使用人数的统计数据吗？

关于 yolo 模式的统计数据，我们可能有，我是说在内部我们没有，但那只是因为我觉得我们有更高的安全姿态。我不确定，我可能可以查一下。关于 bash 还有其他问题吗？

好的，酷。是的，只是给你们一些更多的例子，比如说你有一个邮件 API，你想要获取"告诉我这周谁给我发了邮件"，对吧？所以，你有两个 API。你有一个收件箱 API 和一个联系人 API。这是你可以通过 bash 做到的方式。你也可以通过代码生成来做到这一点。这有点像足够的 bash，它就是代码生成，对吧？bash 表面上是代码生成工具。

然后是的，比如说你想要，你有一个视频会议代理，对吧？你想说"在这个财报电话会议中找到发言人说'季度结果'的所有时刻"，对吧？你可以使用 ffmpeg 来切分这个视频，对吧？你可以使用 jq 来在之后开始分析信息。所以是的，有很多强大的方式来使用 bash。

我要谈一下工作流和代理。是的，你可以两样都做。你可以在代理 SDK 上构建工作流和代理。代理就像 Claude Code。如果你正在构建一些你想要用自然语言与之交谈并灵活采取行动的东西，对吧？那就是你构建代理的原因，对吧？比如你有一个与你的业务数据对话的代理，你想要获得洞察或仪表板或回答问题或写代码或类似的东西，这就是代理，对吧？

然后工作流有点像，你知道，我们做很多 GitHub actions，对吧？所以你非常密切地定义输入和输出，对吧？所以你说，"好的，接受一个 PR 并给我一个代码审查。"你可以为这两者使用代理 SDK。构建工作流时，你可以使用结构化输出。我们刚刚发布了这个。你可以搜索"代理 SDK 结构化输出"。

但是是的，所以你可以两样都做。我现在主要要谈论代理。你可以从中学到的很多东西也适用于工作流。所以，我们会谈论这个。等等，举手表决。有多少人以前设计过代理循环？好的，酷。好的，很棒。

我认为设计代理循环的第一要务，对我来说的元学习就是一遍又一遍地阅读转录本。每次你看到代理运行时，只要阅读它并弄清楚，"嘿，它在做什么？为什么它要这样做？我能以某种方式帮助它吗？"对吧？我们稍后会做一些这样的事情，对吧？所以我们会构建一个代理循环。

但这里是代理循环的三个部分，对吧？首先是收集上下文，对吧？第二是采取行动，第三是验证工作，对吧？这不是构建代理的唯一方式，但我认为是思考它的一个很好的方式。收集上下文就像，你知道，对于 Claude Code，它是 grep 和找到需要的文件，对吧？你知道，对于邮件代理，它就像找到相关的邮件，对吧？

所以这些都是非常重要的，我认为思考它如何找到这个上下文非常重要，我认为很多人有点跳过这一步或者考虑不足。这可能非常非常重要。然后是采取行动，它如何完成工作？它有正确的工具来做吗？比如代码生成、bash，这些是采取行动的更灵活的方式，对吧？

然后验证是另一个非常重要的步骤。所以我现在基本上要说的是，如果你想构建一个代理，想想你能验证它的工作吗？如果你能验证它的工作，它就是代理的一个很好的候选者。如果你不能验证它的工作，比如，你知道，编码你可以通过 linting 来验证，对吧？你至少可以确保它能编译。所以这很棒。

如果你在做深度研究，实际上验证你的工作要困难得多。你可以做的一种方式是引用来源，对吧？所以这就像验证中的一步，但显然研究在某些方面比代码不太可验证，对吧？因为代码有编译步骤，对吧？你也可以执行它，然后看看它做什么，对吧？

所以我认为在我们构建代理时，最接近非常通用的那些是具有非常强验证步骤的那些，对吧？所以我觉得这里有一个问题。

主持人：那么你在哪里生成工作计划？

是的，我是说你可能会...

主持人：问题。

哦是的，抱歉，问题是你什么时候生成计划，在你运行它之前。所以在 Claude Code 中你不总是生成计划。但如果你想要的话，你会在收集上下文和采取行动步骤之间插入它，对吧？所以计划有点帮助代理逐步思考，但它们会增加一些延迟，对吧？所以这里有一些权衡。但是的，代理 SDK 也可以帮助你做一些规划。

主持人：是的。你能让代理创建那个待办事项列表，100% 确保它会创建那个待办事项列表并运行它吗？

是的。所以问题是代理会创建待办事项列表吗？是的。如果你使用代理 SDK，我们有一些随附的待办事项工具，所以它会维护和检查待办事项，你可以在进行时显示它们。是的。

关于这个现在还有其他问题吗？好的，酷。好的，所以我要快速谈论一下你如何做这些事情？你有什么工具来做这件事，对吧？有三样东西你可以做，你有工具、bash 和代码生成，对吧？我认为传统上很多人只考虑工具，基本上行动号召之一就是想得更广泛一点，对吧？

工具极其结构化且非常非常可靠，对吧？如果你想要尽可能快的输出，错误最少，重试最少，工具很棒。缺点是，它们是高上下文使用。如果有人用 50 或 100 个工具构建了代理，对吧？它们占用大量上下文，模型有点会变得困惑，对吧？

### (30:00 - 45:00) Part 3

### (30:00 - 40:00) 工具 vs Bash vs 代码生成
> 三种执行方式的权衡与最佳实践

我认为我们正在朝着一个方向发展，越来越多的东西都被存储在文件系统中，这就是一个很好的例子。它会随着时间存储长输出。我认为通常提示代理这样做是一个好的思考方式。或者即使你有，我现在总是做的一件事就是每当我有工具调用时，我会将工具调用的结果保存到文件系统中，这样你就可以搜索它，然后让工具调用返回结果的路径。这有助于它重新检查自己的工作。

主持人：你是否发现需要使用技能结构来帮助 Claude 更好地使用 bash，还是开箱即用就可以？这不是必需的。

所以问题是关于技能，我们是否需要技能来更好地使用 bash？让我给你解释一下技能的背景。技能基本上是一种允许我们的代理处理更长、更复杂任务的方式，通过上下文加载内容。比如我们有一堆 DOCX 技能，这些技能告诉它如何生成代码来创建这些文件。

技能实际上就是文件的集合。它们也是一个非常依赖文件系统或 bash 工具的例子，因为它们实际上就是代理可以进入并读取的文件夹。我们发现技能真正擅长的是需要大量专业知识的可重复指令。

比如，我们最近发布了一个前端设计技能，我真的很喜欢，它实际上就是关于如何做前端设计的非常详细和优秀的提示。但它来自我们最好的 AI 前端工程师，他真的投入了很多思考和迭代。

主持人：为什么要使用那个前端技能？

它很不错，谢谢发布。我想了解一下，有多个 MP 文件，MP 也在那里，而且也在用户级别，然后还有技能文件。是否有优先级顺序？某些内容应该放在 claude.md 中，其他内容应该只放在 skill.md 中吗？

这个问题是关于 skill.md 与 claude.md 以及如何思考它们。我要说所有这些概念都很新，Claude Code 甚至是八九个月前才发布的，技能是两周前才发布的。我不会假装知道所有最佳实践。

我认为技能是一种渐进式上下文披露的形式，这是我们一直在谈论的一种模式。就像使用 bash 而不是纯粹的普通工具调用一样，这是代理说"好的，我需要做这个，让我找出如何做，然后让我读取这个技能"的方式。所以你要求它创建一个 docx 文件，然后它进入目录，读取如何做，编写一些脚本并继续。

关于如何准确定义技能以及如何拆分，仍有很多直觉需要建立。还有很多最佳实践需要学习。

主持人：昨天我们谈到了技能随时间发展的未来。你是否认为这些最终会成为模型的一部分，一些技能只是现在弥合差距的方式？

所以问题是技能最终是否是模型的一部分？它们是弥合差距的方式吗？我错过了昨天 Barry 的演讲，但我认为大致的想法是模型在执行各种任务方面会变得越来越好，技能是给它分布外任务的最佳方式。

但我广泛地说，特别是如果你不在实验室工作，要准确预测模型的发展方向真的很难。我的一般经验法则是我尝试每6个月重新思考或重写我的代理代码，因为我觉得事情可能已经发生了足够的变化，我已经烘焙了一些假设。

我认为我们的代理 SDK 是为了尽可能地随着能力发展而前进。bash 工具会变得越来越好。我们在 Claude Code 之上构建它，所以随着 Claude Code 的发展，你会立即获得这些胜利。

但同时，现在的情况与一年前在 AI 工程方面如此不同。我认为一个通用的最佳实践是，我们可以快10倍地编写代码，我们也应该快10倍地丢弃代码。我认为思考的是不要对未来在哪里下注，而是今天我们能做什么真正有效的事情，让我们今天获得市场份额，不要害怕以后丢弃代码。

如果你是一家初创公司，这可以说是你相对于竞争对手的最大优势。较大的公司有六个月的孵化周期，所以他们总是困在代理能力的过去。你的优势是你可以说，代理能力现在就在这里，让我现在构建一些使用这个的东西。

还有其他关于技能和 bash 的问题吗？看起来有很多技能问题。

主持人：为什么使用技能而不是 API？它们看起来与那个 Python 程序非常相似，那可能是一个包。

这个问题是为什么使用技能而不是 API？好问题。我认为这些都是渐进式披露的形式，基本上是为了让代理弄清楚它需要做什么。这完全取决于用例。我认为没有通用规则。我认为就是阅读转录并看看你的代理想要什么。如果你的代理总是将 API 想象为 API.ts 文件或 API.py 文件，那就这样做。

技能是一种将文件系统作为存储上下文方式思考的介绍，它们是很好的抽象。但有很多使用系统的方式。

### (40:00 - 50:00) Agent 设计循环
> 收集上下文、执行动作、验证工作的三步循环

关于技能，你需要 bash 工具，你需要虚拟文件系统等等。所以代理 SDK 基本上是现在真正充分使用技能的唯一方式。

主持人：我们能期待技能的市场吗？

所以问题是我们能期待技能的市场吗？Claude Code 有一个插件市场，你也可以在代理 SDK 中使用。我们正在不断发展，这更像是一个发现系统，我认为。但它现在存在，你可以在 Claude Code 中使用插件。

主持人：你目前对何时使用 SDK 来解决问题的想法是什么？

何时使用 SDK 来解决问题？如果我正在构建代理，我的总体信念是，对于任何代理，bash 工具给你如此多的力量和灵活性，使用文件系统给你如此多的力量和灵活性，你总能从中获得性能提升。

在这次演讲的原型部分，我们将看一个只有工具的例子和一个带有 bash 和文件系统的例子，并比较这两个。这就是我所说的"勇敢构建"的意思。我就是从代理 SDK 开始，我认为 Anthropic 的很多人也开始这样做。

当然，我要说有很多时候代理 SDK 有点烦人，因为你有这个网络沙盒容器，你会想"我讨厌这个，我不想这样做，我想在我的浏览器上本地运行"。我完全理解，确实有真正的性能权衡。

我的思考方式有点像 React 与 jQuery。当我刚入行时，我很喜欢 web 开发，我使用 jQuery 和 Backbone，然后 React 出现了，它是 Facebook 开发的，他们说"你必须，这是 JSX，我们刚编造的"，现在有了打包器。我当时想，这太烦人了。但它通常使模型或使 web 应用更强大。我认为代理 SDK 对我来说就像是代理框架的 React，因为我们在它之上构建我们自己的东西。

所有烦人的部分都是我们也为之烦恼的地方，但我们觉得它就是有效的，你必须这样做。

还有更多技能问题。

主持人：自定义内部 bash 工具，你如何让代理发现这些，还是它们必须成为工具？

如果你有自定义代理 bash 工具，如何让代理发现？你是说 bash 脚本吗？你只需将它放在文件系统中并告诉它"这里有一个脚本，你可以调用它"。我通常在 Claude 代理 SDK 的上下文中思考，它有文件系统和 bash 工具绑定在一起。我有时看到的一种反模式是人们说"我们要在这个虚拟化的地方托管 bash 工具，它不会与代理循环的其他部分交互"，这使得它变得困难，因为如果你得到一个保存文件的工具结果，那么你的 bash 工具就无法读取它，除非它们都在一个容器中。

### (45:00 - 1:00:00) Part 4

你说"嘿，我只能接受这个输入，我需要给出这个输出，我必须对代理屏蔽数据库的其他一切信息"，这显然限制了代理的能力，它无法编写非常动态的查询。如果你要编写完整的 SQL 查询，我肯定会使用 bash 或 cogen，因为当模型编写 SQL 查询时，它可能会出错，修复错误的方式是通过检查或运行文件，查看输出，看是否有错误，然后进行迭代。

所以一般来说，如果我今天构建一个代理，我会给它尽可能多的数据库访问权限，然后设置防护栏。我可能会以不同的方式限制它的写入访问权限。但我可能会做的是给它写入访问权限并设置特定规则，然后如果它试图做它不能做的事情就给它反馈。我知道这是一个困难的问题，但我认为这是我们需要解决的一系列问题。我们构建了一个 bash 工具解析器，这是一个非常讨厌的问题，但我们需要解决它才能让代理普遍地工作。数据库也是一样的，是的，理解查询在做什么确实很困难，但如果你能解决这个问题，随着时间的推移，你可以让你的代理工作得更普遍。

所以我认为要尽可能灵活地思考，并保持工具像非常原子化的操作，你需要很多保证。

主持人：跟进同样的问题，你如何确保基于角色的访问控制得到处理？

通常这在你如何配置你的 API 密钥或你的后端服务中。我认为我可能会做的是创建临时 API 密钥，有时人们会在中间创建代理来插入 API 密钥，如果你担心泄露的话。但是，我会为你的代理创建在某些方面有范围限制的 API 密钥，这样在后端你可以检查它试图做什么，如果它是一个代理，你可以给它不同的反馈。

主持人：好的，我还有一个问题。你能告诉我们更多关于内存工具，内部内存工具的信息吗？

我不是试图保密。我不知道确切的情况，我还没有读过代码，但我认为它一般是在文件系统上工作的。

主持人：你把它暴露给 SDK 还是已经可用了？

我们经常遇到这个问题。在 cloud agent SDK 中，我会直接使用文件系统。我会创建一个像记忆文件夹之类的东西，告诉它把记忆写在那里。我不知道内存工具的确切实现，但它确实以这种方式使用文件系统。

### (50:00 - 1:10:00) 电子表格 Agent 案例分析
> 通过具体案例展示 Agent 设计的创造性思维

主持人：最后一个问题，你如何管理代码的可重用性？假设同一个代理被部署给数百个用户，每次都在生成和执行相同的代码。我们如何利用可重用性？

这是一个非常好的问题。假设你有两个代理与两个不同的人交互，问题是你如何考虑代理之间的可重用性或代理如何通信。我认为这有待发现。传统上，在 web 应用中，你为一百万人提供一个应用，但对于代理，像 cloud code，我们提供一对一的容器，当你在网络上使用 cloud code 时，它是你的容器，所以容器之间没有太多通信，这是一个非常不同的范式。

我不会说我确切知道最佳的系统设计来做到这一点，我认为在如何让这些代理重用工作方面有很多最佳实践，我们如何给他们通用脚本来组合他们已经完成的工作，我们如何让他们分享。关于代理通信框架，我个人认为我们可能不需要重新发明一个新的通信系统。代理擅长使用我们已有的东西，比如 HTTP 请求、hash 工具、API 密钥和命名管道等等。所以代理们可能只是使用 HTTP 服务器相互发送 HTTP 请求。

有一些有趣的工作。我见过人们为他们的代理创建虚拟论坛进行通信，他们发布话题并回复之类的，挺酷的。我认为那里有很多值得探索和发现的东西。

好的，我们继续。时间怎么样？我想还有一个小时。酷，这是一个设计代理的例子。这不是原型会议，但我认为这会是一个很好的引导。假设我们在制作一个电子表格代理。搜索电子表格的最佳方式是什么？在电子表格中执行代码或采取行动的最佳方式是什么？链接电子表格的最佳方式是什么？这些都是非常有趣的事情。

我要做一个 Figma，我们可以过一遍。如果有人能拿点水那就太好了，我真的需要水。好的，谢谢。

所以我们要谈论一下，或者你们为什么不花几分钟时间自己思考这个问题？你有一个电子表格代理。你希望它能够搜索，能够收集上下文、采取行动、验证其工作。你会如何考虑？所以花点时间思考一下，做些笔记什么的。

好的，大家有时间思考这个问题了吗？有人想要更多时间还是想直接深入？好的。代理搜索电子表格的最佳方式是什么？我意识到我现在必须用一只手打字。我应该想办法解决这个问题，因为我稍后要打字。

搜索电子表格。有什么想法吗？你如何搜索电子表格？你会做什么？

观众：CSV。

好的，你有一个 CSV。现在你的代理想搜索 CSV，它会做什么？

观众：grep。

好的，grep 看起来像什么？

观众：需要查看所有标题。

查看标题，好的。

观众：所有表的标题。

好的，很棒。假设我在寻找 2024 年的收入或类似的东西。现在我有了我的标题，我要打开一个电子表格。假设这里有一个收入列，然后还有...

假设是这样的，我如何获得 2026 年的收入？这是一个表格问题，这里有收入，这里也有 2026，所以这是一个多维步骤。我们可以查看标题，然后如果你只是拉取这个，你会得到 100、200、300。所以我们需要更多一点。还有其他想法吗？

观众：有一个 bash 工具，AWK。

好的，它会 AWK 什么？

观众：嗯，取决于你在寻找什么。

是的，这就是问题，用户在寻找什么，他们可能在寻找像这样的东西，比如 2026 年的收入。

观众：也许使用 API 来使用 Google 工具将所有数字加在一起或 V 查找类似的东西。

是的，所以想法是使用 API，比如使用 Google API 来查找。那很棒。但是，假设我们在本地工作，我们需要设计这些 API。

观众：SQLite 或直接使用 CSV。

哦，有趣。我不知道这一点，那太棒了。所以你使用 SQLite 来查询 CSV。这是一个很好的创造性思考 API 接口的方式。如果你能将某些东西转换成代理非常了解的接口，那就太棒了。所以如果你有一个数据源，如果你能将其转换为 SQL 查询，那么你的代理真的知道如何搜索 SQL。所以思考这个转换步骤真的非常有趣，这是设计代理搜索接口的好方法。

观众：抱歉，我们在谈论工具的时候快速说一下，因为你也可以对其中一些内容使用 TSV。Claude 是否足够智能，能够开始为合适的工作排列合适的工具？因为这正是我们在这里讨论的，合适的工作用合适的工具。

Claude 是否足够智能，能够为合适的工作排列合适的工具？是的，如果你提示它，我认为这是那些我们不知道的事情之一，让我们找出来，让我们阅读记录。如果不是，你如何帮助它？

我认为所有这些事情都像是直觉，就像骑马一样。不是说我曾经骑过马，但我知道就像我想象的那样像跑步一样。

[笑声]

你给这匹马这些信号，你在安抚它，你试图理解如何让它跑得更快。这是一个非常有机的事情。我们喜欢说模型是成长的而不是设计的，所以我们在理解它们的能力。

观众：快速问题，有没有办法给电子表格添加元数据？你能在不同的文档中给出描述吗？

是的，比如 KPI 构建智能来问问题。

是的，这是另一个很好的模式，你能给电子表格添加元数据吗？所以当你考虑搜索时，你可能想考虑的一些问题是，你能做什么预处理来让搜索更好？一个例子是你将其转换为 SQL 格式或使用可以查询它的东西，这是一个翻译步骤。另一个步骤是也许你有一个工具或预处理步骤，另一个代理注释电子表格并添加信息，这样代理就可以更好地搜索这些信息。

### (1:00:00 - 1:15:00) Part 5

你可以做 SQL 查询，对吧？代理对 SQL 查询相当熟悉。你也可以做 XML，抱歉，字体太小了。是的，你也可以做 XML。我不确定你们是否知道，XLS 文件在后端实际上是 XML，XML 非常结构化，你可以做 XML 搜索查询，有不同的库可以做到这一点。这就是一个例子，关于如何搜索和收集上下文。我希望这能向你们说明，收集上下文真的非常有创造性，有很多迭代方式。如果你只尝试了一种迭代，那可能还不够。想想你能想到的尽可能多的不同方法，尝试这些方法。尝试 SQL，尝试 CER，尝试 GPT-O 和所有这些东西，准备一些测试用例在不同的方法上试验，看看代理喜欢什么，不喜欢什么。每种情况都会有所不同。

观众：抱歉，当你说代理时，你是指模型还是因为我们正在构建一个代理？

是的，你依赖的是已有的关于如何处理 XML 的知识，是谁在做这件事？是模型。

是的，因为问题是知识从哪里来？是来自模型吗？我说的代理是什么意思？通常我认为你要寻找的是，你有一个问题，你想让它尽可能符合代理的分布，对吧？代理对很多不同的事情都有很多了解。比如它对金融了解很多，所以如果你要求它制作一个 DCF 模型，它知道什么是 DCF。如果你想给它更多信息，你可以制作一个技能，但它知道什么是 DCF，知道什么是 SQL。它能将这些东西结合在一起吗？理想情况下，你的问题在某种程度上会超出分布范围，比如有一些不在互联网上的信息，或者对你来说有些独特的东西，你想尽量将其调整得尽可能符合分布。这非常有创造性，我认为这不是一门科学，更像是一门艺术。

好的，我们已经尝试了收集上下文，然后是采取行动。我们可能可以在这里做很多我们之前做过的相同事情。比如我们可以插入二维数组。如果我们有一个 SQL 接口，我们可以做 SQL 查询，可以编辑 XML。这些通常非常相似，采取行动和收集上下文，你可能希望有类似的 API 来回传递。

然后最后一件事是验证工作。你如何思考验证？检查空指针是其中一种方法。关于验证还有其他想法吗？

观众：抱歉，我有点困惑，如果你说当你使用其他 SDK 来构建代理时，我不需要告诉它应该如何收集上下文。

当然。

观众：我只是给它上下文，用简单的英语解释它应该做什么。

是的。

观众：我倾向于做的是，你告诉我我是否错了，我实际上最终会创建一个单独的代理来做 QA。

哦，有趣。

观众：来验证，因为我不信任代理验证自己的工作。但我只是对在那个例子中我需要向代理提供多少详细信息感到困惑。

是的，好的。所以问题是关于给代理上下文与让它收集自己的上下文。你提到有时会使用 QA 代理。我能问问你在哪个领域构建你的代理吗？

观众：网络安全。

好的，当然。我认为 Claude Agent SDK 对网络安全很有用，我通常会推动人们尽可能让代理收集上下文，让它尽可能找到自己的工作。你试图给它工具来找到自己的工作。我思考这个问题的方式有点像，假设有人把你锁在一个房间里，他们给你任务，这就是你的工作，像 Mr. Beast 的场景一样。如果你在这个房间里待 6 个月就能得到 50 万美元。然后有人给你发消息，你想要什么工具来完成它？你只想要一叠论文吗？还是想要计算器或电脑？我可能想要电脑，想要 Google，想要所有这些东西。我不希望那个人给我发送一堆论文说"嘿，这可能是你需要的所有信息。"我更愿意他们说"嘿，给我一台电脑，给我问题，让我搜索并解决它。"我对代理也是这样想的，他们被困在一个房间里。

观众：所以我需要给他们工具。如果你能回到你之前展示的图表...

是的，就像这个图表。

观众：基本上收集上下文就是我提供给它的这些工具。

是的，完全正确。我给它的可能是代码生成的 API，可能是 SQL 工具，可能是 bash。这些都是例子。

观众：还有一个问题。对于你拥有的所有代理，它们共享同一个上下文窗口吗？

有趣的问题。代理是否共享上下文窗口？我认为这是一个关于如何管理上下文的有趣问题。我认为，虽然我还没有谈论太多，但子代理是管理上下文的非常重要的方法。我们在 Claude Code 中越来越多地使用子代理，我会非常普遍地考虑使用子代理。

对于电子表格代理，我们可能会有一个搜索子代理。子代理很适合当你需要做大量工作并向主代理返回答案时。对于搜索，假设问题是"我如何找到 2026 年的收入？"也许你需要做很多结果搜索，也许你需要搜索互联网，搜索电子表格等等。有很多东西不需要进入主代理的上下文。主代理只需要看到最终结果。这就是一个很好的子代理任务。我这里没有专门的子代理幻灯片，但它们非常有用，我认为是思考问题的好方法。

观众：为了建立在这个问题上，对于验证，你可以想象通过技能或子代理来做这件事。你甚至可能想要一个对抗性的...安全例子是一个很好的例子。想要真正深入研究它，与已经完成的工作没有任何同情关系。这是一个光谱，但你会在这里使用子代理吗，还是使用技能？你如何思考这个问题？

是的，绝对的。关于是否使用子代理进行验证的问题。是的，我认为这是一种模式。理想情况下，最好的验证形式是基于规则的，比如是否有空指针之类的？这很容易验证。代码不能编译或通过语法检查，尽可能多地插入规则，再次要有创造性。例如，在 Claude Code 中，如果代理尝试写入一个我们知道它还没有读取的文件，我们会抛出错误，告诉它"嘿，你还没有读取这个文件，先尝试读取它。"这是我们插入到验证步骤中的确定性工具的例子。

尽可能多地，每当你思考验证时，第一步是你能确定性地做什么，你知道什么样的输出可以做。当你选择要制作哪种类型的代理时，那些有更多确定性规则的代理更好，这很有意义。

### (1:10:00 - 1:30:00) 原型开发实战：宝可梦 Agent
> 使用 Claude Code 快速原型开发的完整流程

当然，随着模型在推理方面越来越好，你就可以拥有这些检查主代理工作的子代理。主要的事情是避免上下文污染。你可能不想分叉上下文，你可能想开始一个新的上下文会话，就像"嘿，对抗性地检查这个输出，这是由麦肯锡的初级分析师制作的，他们毕业于一所不太好的学校，GPA 不高"，给它一堆东西，然后告诉它批评它。这就是子代理的工具之一。随着模型越来越好，这种验证也会变得更好。但确定性地做这件事是一个很好的开始。

观众：关于验证工作的问题。假设我们发现了空指针，说"好的，修复它"可能很容易。但假设我们将它部署到生产环境，客户在使用它，不是我们，他们somehow进入一个整个电子表格被删除的情况。我们需要在什么层面上构建撤销工具的能力？

比如 QA 代理返回他们的电子表格是空的，但不一定能够撤销，你的建议是什么？

是的，问题是你如何思考状态、撤销和重做，基本上是修复错误的能力。我认为这是一个非常好的问题，诚实地说，当你思考代理擅长什么问题领域时，工作的可逆性程度是一个非常好的直觉。代码是相当可逆的，你可以回退，可以撤销 git 历史。我们开箱即用就有这些原子操作。我通过 Claude Code 经常使用 git，我不再输入 git 命令了。这是一个非常好的例子。

一个非常坏的例子是计算机使用，因为计算机使用在状态上不可逆。假设你去 DoorDash.com，用户想要你订一杯可乐，但你加了百事可乐，现在你不能只是回去点击可乐，你必须去购物车删除百事可乐。你的错误使这种状态复杂化了，状态机变得更复杂。

每当你处理非常复杂的状态机，无法撤销或重做时，确实会变得更困难。作为工程师，你面临的问题之一是你能否将其转变为可逆状态机？就像你说的，你能否在检查点之间存储状态，这样用户可以说"哦，我的电子表格现在搞砸了，回到之前的检查点"？甚至模型能否回到之前的检查点？我认为有人有这种时光旅行工具，他们给编码代理使用，这很酷，就像你可以时光倒流到这件事发生之前。我认为所有这些工具，有些现在还不能很好地工作，但我们会到达那里。思考状态和验证非常有用。

观众：我很好奇规模问题。如果电子表格有数百万行、几十万列，或者任何类型的数据库，在这种情况下你如何搜索？显然有上下文限制...

这很好，我可能应该用电子表格例子作为我的编码例子，而不是 Pokemon 代理，电子表格可能会更好。

问题是如果电子表格非常大怎么办？如果你有一百万行、十万列或一百列，你如何思考这个问题？你的数据库也很大，你如何处理？

我认为对于所有这些事情，当然随着数据变得越来越大，这就是一个更难的问题，你的准确性会下降。Claude Code 在较大的代码库中比在较小的代码库中表现更差，随着模型变得更好，它们在所有这些方面都会变得更好。

对于所有这些，我会思考如果我有一个一百万列一百万行的电子表格我会怎么做？我需要开始搜索它。我会像搜索收入一样，使用 Ctrl+F 搜索收入，然后我会检查每个结果，看这是否正确。然后我会看是否有数字，我可能会保留一个草稿，一个新的工作表，我会写"等于收入等于这个"，存储这个引用并继续。我认为这是思考它的好方法，模型永远不应该将整个电子表格读入上下文，因为那会占用太多空间。你想给它适当的起始上下文量，这也是你工作的方式。

### (1:15:00 - 1:30:00) Part 6

主持人：我的问题是关于管理上下文污染的，实际上我想这与之前的问题相关。你有没有经验法则，比如在开始遇到收益递减或变得不那么有效之前，你会使用上下文窗口的多少比例？

嘉宾：是的，这个问题关于上下文管理。你有没有关于在变得不那么有效之前应该使用多少上下文窗口的经验法则？这实际上是现在一个非常有趣的问题。

我觉得很多时候当我和使用 Claude Code 的人交谈时，他们会说："我已经压缩了五次了。"我就想，什么？我几乎从来没有做过压缩。你知道我的意思吗？我必须通过强迫自己被压缩来测试用户体验，仅仅因为我在使用 Claude Code 时倾向于非常频繁地清除上下文窗口。

至少在代码中，状态是在代码库的文件中，对吧？所以假设我做了一些更改，Claude Code 可以查看我的 git diff 然后说："哦嘿，这些是你做的更改。"它不需要知道我与它的整个聊天历史来继续新任务，对吧？所以在 Claude Code 中我非常非常频繁地清除上下文，我会说："嘿，看看我未完成的 git 更改。我在做这个。你能帮我以这种方式扩展吗？"这是思考它的一种方式。

当你构建自己的 agent 时，比如说我们正在构建一个电子表格 agent，情况会变得更复杂一些，因为你的用户技术性较低，对吧？他们不知道上下文窗口是什么。我认为这是一个难题。我觉得这里有一些用户体验设计，比如你能重置对话状态吗？也许每次用户问新问题时你可以做自己的压缩或其他什么，你可以总结上下文？

在电子表格中，很多状态都在电子表格本身中，所以它可能不需要知道整个上下文。你能存储用户偏好吗？随着进行，你能记住这些东西吗？有很多不同的角度和方式可以做到这一点，这又是一门艺术。你试图最小化上下文使用。你可能不需要一百万上下文或什么的，你只需要好的上下文管理和用户体验设计。

观众：我想问的是子代理是为了保护核心代理的行为而制作的，对吧？

嘉宾：没错。是的，子代理是为了...

观众：电子表格。在电子表格超大的情况下，我们能否使用多个子代理并尝试创建一个过程，将电子表格分块。然后这些代理可以并行处理每个部分。

是的。我是说，我喜欢 Claude Code 的一个原因是我们在使用子代理方面提供了最佳体验，特别是带有 bash 的子代理，非常非常好。我之前没有完全意识到所有的痛点。我想如果有人要去 QCON，我相信 Adam Wolf 会在 QCON 上就我们如何实现 bash 工具给出演讲。Adam 是个传奇，bash 工具做得非常出色。

当你同时运行并行子代理时，bash 变得非常复杂，有很多竞争条件之类的，所以我们在那里解决了很多工作。这是我喜欢 Claude Code 的原因之一，你可以说："嘿，启动三个子代理来做这个任务"，它就会做到，在 Agent SDK 中你也可以要求它这样做。所以第一，子代理是 Agent SDK 中的一个很好的原语，我没有看到任何人做得这么好。这是使用它的一个重要原因。

是的，通常你希望这些子代理保持上下文。假设你有一个电子表格，你可能同时有多个读取子代理，对吧？所以也许主代理会说："嘿，这个代理能读取并总结表格一吗？这个代理能读取并总结表格二吗？这个代理能总结表格三吗？"然后它们返回结果，然后代理可能再次启动更多子代理。这是你拥有的另一个控制旋钮。

我想说的是，我们已经谈论了这么多不同的创造性方法来做事情。这是你应该思考问题的层面。在我看来，你真的不应该考虑如何启动一个进程来制作子代理，或者像子代理背后的系统工程或什么是压缩之类的事情。我们在 harness 中为你处理所有这些，这样你就可以考虑我需要启动什么子代理，如何创建代理搜索界面，以及如何验证它的工作。这些是你必须解决的真正核心和困难的问题。任何时候你花在不解决这些问题而是解决低级别问题上的时间，你可能没有为你的用户提供价值。所以是的，我是子代理的大粉丝，也是 Agent SDK 的大粉丝。

### (1:30:00 - 1:45:00) Part 7


---

*生成时间: 2026-01-06 06:26:25*
*由 YouTube Monitor & Translator (Claude CLI) 生成*