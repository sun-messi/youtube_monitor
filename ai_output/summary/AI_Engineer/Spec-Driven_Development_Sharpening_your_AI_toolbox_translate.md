# Spec-Driven Development: Sharpening your AI toolbox - Al Harris, Amazon Kiro

## 📹 视频信息

- **频道**: AI Engineer
- **发布日期**: 2026-01-09
- **时长**: 1:03:51
- **原始链接**: [https://www.youtube.com/watch?v=HY_JyxAZsiE](https://www.youtube.com/watch?v=HY_JyxAZsiE)

---

> 本文内容整理自 AWS Kuro 团队首席工程师艾尔·哈里斯（Al Harris）在 AI Engineer 频道的技术演讲。

---

## TL;DR

Spec驱动开发（Spec-Driven Development）通过结构化的需求、设计和任务流程，让AI代码生成从"靠感觉"转变为"有章法"——不仅代码质量更可靠，还能通过基于属性的测试（PBT）自动验证系统正确性，解决了AI编程中最头疼的准确性和可控性问题。

---

## 📑 章节导航表

| 时间戳 | 章节标题 | 一句话概括 |
|--------|----------|-----------|
| 00:20-03:23 | Kuro与Spec驱动开发介绍 | Kuro是AWS推出的AI开发工具，通过规范驱动开发提升AI编程的可控性 |
| 03:23-06:59 | Spec驱动开发的核心理念 | 将传统软件开发生命周期与AI结合，通过需求→设计→实现的结构化流程提升代码质量 |
| 06:59-11:04 | MCP集成与工具链优化基础 | 展示如何使用MCP服务器扩展Kuro能力，从外部系统获取上下文 |
| 11:04-19:09 | 自定义工件与流程优化 | 演示如何在spec中添加UI原型、测试用例等自定义内容，打磨工具链 |
| 19:09-36:26 | 实战演示：Agent Core项目 | 通过真实项目展示spec驱动开发全流程，包括需求生成、设计和任务执行 |
| 36:26-59:33 | Q&A：深入探讨实践细节 | 回答关于大型代码库、上下文管理、AWS集成等实际应用问题 |
| 59:33-63:48 | 代码生成与测试验证 | 展示最终代码生成结果，包括属性测试和提交管理 |

---

## 📊 核心论点

### 1. AI编程的核心挑战：从"靠感觉"到"有规范"

- **核心内容**：传统AI编程（vibe coding）过度依赖操作者的即时判断和手动引导，缺乏系统性保障。Spec驱动开发引入了25-30年软件工程实践的精髓，通过需求（Requirements）→设计（Design）→实现（Implementation）的结构化流程，将模糊的意图转化为明确的规范。系统采用EARS（Easy Approach to Requirements Syntax）格式编写需求，这种结构化自然语言既便于人类理解，又能被机器解析。
- **关键概念**：Spec驱动开发、EARS格式、结构化工作流、软件开发生命周期（SDLC）、需求形式化
- **实际意义**：开发者不再需要反复调试prompt来获得正确结果，而是通过前期的规范定义确保AI理解意图；企业可以将AI编程纳入正规的软件工程流程，提高代码质量和可维护性；减少了AI生成代码的不确定性，使其更适合生产环境。

### 2. 基于属性的测试（PBT）：AI代码的正确性保障

- **核心内容**：Kuro将EARS格式的需求自动转换为系统属性（不变量），通过属性测试框架（如Python的Hypothesis、Node的fast-check）生成测试用例。与传统单元测试不同，PBT尝试找到违反系统属性的反例——如果找不到任何反例，则可以高度确信系统符合规范。这解决了AI生成代码最大的痛点：LLM经常声称"完成了"但实际存在bug。
- **关键概念**：属性测试、系统不变量、需求验证、自动化测试生成、正确性证明
- **实际意义**：将测试从事后补救变为设计时保障，大幅提升AI生成代码的可靠性；企业可以放心地将AI生成的代码用于关键系统；开发效率提升的同时不牺牲质量。

### 3. MCP（Model Context Protocol）集成：打破AI的信息孤岛

- **核心内容**：MCP允许Kuro在spec生成的任何阶段（需求、设计、实现）访问外部系统。演示中展示了从Asana拉取任务生成需求、使用AWS文档MCP获取最新API信息、通过GitHub MCP访问代码库等场景。这解决了AI工具普遍存在的上下文受限问题，让AI能够基于真实、最新的信息做决策。
- **关键概念**：MCP服务器、外部系统集成、动态上下文、工具链扩展、实时信息获取
- **实际意义**：AI不再是"闭门造车"，可以访问企业内部系统、最新文档和实时数据；开发团队可以将现有工具链无缝集成到AI工作流中；大幅提升了AI在复杂企业环境中的实用性。

### 4. 渐进式工具链优化：从200目到800目砂纸

- **核心内容**：Harris使用砂纸打磨的比喻，展示了三个层次的优化：200目（基础MCP集成）、400目（自定义工件如UI原型图、测试用例）、800目（迭代优化流程，挑战初始假设）。特别强调了不要被初始prompt锁定思路——演示中展示了如何质疑"使用S3存储"的决定，让AI探索更好的方案（如Agent Core Memory）。
- **关键概念**：工具链优化、迭代改进、自定义工件、流程灵活性、避免过早决策
- **实际意义**：团队可以根据自己的需求定制AI开发流程，而非被工具限制；鼓励在设计阶段多探索替代方案，避免技术债务；强调了人机协作中"人"的判断力仍然至关重要。

### 5. 文档即代码：Spec作为活的系统文档

- **核心内容**：与传统的设计文档不同，Spec不是一次性的交付物，而是随系统演进的"活文档"。当需求变更时，会产生diff而非重写；新功能会更新现有spec而非创建新文档。Kuro团队内部已经用spec review取代了传统的设计文档评审，通过MCP工具将spec同步到wiki进行协作。
- **关键概念**：活文档、双向同步、需求追踪、版本控制、协作评审
- **实际意义**：解决了文档与代码脱节的老问题；新加入的团队成员可以通过spec快速理解系统；需求变更的影响可以被自动追踪和评估。

### 6. 大型代码库的AI适配策略

- **核心内容**：在回答观众问题时，Harris指出AI在大型代码库中的表现取决于代码组织质量。高内聚、低耦合、良好的模块分离会让AI表现更好——就像人类开发者一样。Kuro通过后台索引支持代码语义搜索，但核心策略是"渐进式披露"：不是一开始就加载所有上下文，而是让AI自己发现需要的信息。
- **关键概念**：代码库索引、语义搜索、渐进式上下文、模块化设计、技术债务影响
- **实际意义**：企业在引入AI辅助开发前，应先评估和改进代码架构；良好的软件工程实践对AI同样重要；AI可以成为推动代码重构的催化剂。

### 7. 多项目协作与跨职能需求管理

- **核心内容**：当一个功能涉及多个系统组件（如API、安全、日志）时，Kuro支持创建跨职能spec或在相关spec间建立关联。新推出的多工作区功能允许同时打开多个项目，拖拽相关文件到同一上下文中工作。这反映了真实软件开发中的复杂性——很少有功能是完全独立的。
- **关键概念**：跨职能协作、多项目管理、需求关联、工作区组织、系统边界
- **实际意义**：支持企业级的复杂项目开发，而不仅仅是单体应用；促进团队间的协作和知识共享；帮助识别和管理系统间的依赖关系。

### 8. 性能优化与缓存策略

- **核心内容**：Kuro通过prompt缓存达到90-95%的缓存命中率，大幅提升响应速度。相比每次发送160k token到AI服务，缓存机制让交互变得流畅。团队正在改进的summarization功能目前需要30-45秒（体验糟糕），目标是实现实时摘要。这种对性能的关注体现了从实验工具到生产工具的转变。
- **关键概念**：Prompt缓存、Token优化、实时响应、性能工程、用户体验
- **实际意义**：AI辅助开发从"等待型"转向"交互型"，提升开发效率；降低了AI服务的使用成本；使AI工具更适合日常开发工作流。

### 9. Steering机制：个性化AI行为

- **核心内容**：通过steering文档，开发者可以定义AI的行为偏好，如代码风格、提交信息格式、测试覆盖率要求等。Harris展示了如何让Kuro在每次提交时自动添加"Co-authored-by: Kuro Agent"。这种机制让AI不是"一刀切"，而是适应每个团队和项目的特定需求。
- **关键概念**：行为定制、代码风格、团队规范、个性化配置、AI训练
- **实际意义**：企业可以将编码规范、安全要求等嵌入AI行为中；减少code review中的风格争议；保持团队代码的一致性。

### 10. 从工具到方法论的转变

- **核心内容**：Spec不仅是一个工具特性，更是一种开发方法论。它包含三个层面：工件（需求、设计、任务清单）、工作流（结构化的开发过程）、工具集（如PBT、需求验证）。这种方法论强调的是可重复性和确定性，而非单纯追求速度。正如Harris所说："如果我花一小时写设计文档，我希望得到正确的结果。"
- **关键概念**：开发方法论、确定性、可重复性、质量优先、投资回报
- **实际意义**：改变了"AI就是快速原型"的刻板印象，使AI适用于要求高质量的生产系统；为AI辅助开发建立了工程标准；帮助团队从ad-hoc使用AI转向系统化应用。

---

## 🏢 提及的公司/产品

| 公司名 | 讨论语境 | 重要性 |
|--------|----------|--------|
| AWS/Amazon | Kuro的开发方，Agent Core平台提供商 | ⭐⭐⭐ |
| Anthropic | Claude模型提供商，MCP协议制定者 | ⭐⭐ |
| Cursor/Windsurf | 竞争产品，同为VS Code分叉的AI IDE | ⭐⭐ |
| Asana | MCP集成示例，展示任务管理系统集成 | ⭐ |
| GitHub | MCP服务器示例，代码库访问 | ⭐⭐ |
| Tavily/Brave | 搜索MCP服务器提供商 | ⭐ |

---

## 💬 经典金句

> "Vibe coding is great, but vibe coding relies a lot on me as the operator getting things right."
> — Al Harris

> "If I spend an hour generating a design doc reviewing it with my team and then synthesizing from that, I want to get it right."
> — Al Harris

> "The agent is generally very easy to please... it will say 'I'm done, I'm happy, I'm sure you're happy' even when tests don't pass."
> — Al Harris

> "We want to use classic automated reasoning techniques to give you high quality results, not just whatever the latest model is going to tell you."
> — Al Harris

---

## 👤 主要人物

### Al Harris（艾尔·哈里斯）

**身份**：AWS Kuro团队首席工程师（Principal Engineer）
**背景**：在AWS工作，领导一个3-4人的小团队，负责从零开始构建Kuro。团队最初"坐在小房间里"探索如何改进软件开发生命周期。虽然理论上隶属于支持QDV的部门，但特意做了完全不同的产品。
**核心观点**：认为AI辅助开发不应该只是"靠感觉"，而需要结合25-30年的软件工程实践。强调准确性比速度更重要——"如果花了一小时写设计文档，就应该得到正确的结果"。推崇用结构化方法（需求→设计→实现）来控制AI，而非单纯依赖prompt工程。

---

## 📺 视频类型判断

**演讲独白**：技术演示与讲解形式，包含现场编码演示和Q&A环节

---

## 📝 完整翻译

### (0:20 - 3:23) Kuro与Spec驱动开发介绍
> Kuro是AWS推出的AI开发工具，通过规范驱动开发提升AI编程的可控性

所以我们被委托构建一个开发工具，来改善规格驱动开发的体验。理论上我们是由支持QDV等工具的组织资助的，但我们故意做了一个与QE系统非常不同的产品套件，对这些事情有不同的看法。

我们想要致力于扩展，帮助你将AI开发扩展到更复杂的问题。提高你对AI智能体的控制程度，并提高代码质量，保持你从流程另一端得到的可靠性。现在我们回到新内容。

我们的解决方案是Spectri。我们查看了市场上的一些现有产品，然后说："嘿，氛围编程很好，但氛围编程很大程度上依赖于我作为操作者把事情做对。也就是说，我要给系统提供护栏，我要让智能体通过一种严格的工作流程。"

我们希望规格驱动开发能够代表整体的软件开发生命周期，因为我们有25到30年的行业经验，构建软件，构建得很好，并使用不同的实践。我们经历过瀑布模型、极限编程，我们有所有这些不同的方式来表示系统应该做什么，我们希望有效地尊重之前的经验。

这个动画看起来更好了。最初只是左边的菱形，但想法是，你基本上是在一个想法上迭代。我认为软件开发的一半是需求发现。而这种发现不仅仅是通过坐在那里思考系统应该做什么、系统能做什么来实现的。

不过，在开发过程中我们意识到，让这些系统工作的最佳方式实际上是合成输出并能够非常快速地反馈。

参与者：是的，完全正确。

演讲者：它会根据你生成的语言而在功能性方面有所不同。我的意思是，我认为没有其他方法来处理这个问题。我只是熟悉Node，所以我在这里用Node做所有事情，但你可以将此系统与任何语言一起使用。

我们技术上支持Java、Python、JavaScript，还有JavaScript、TypeScript、Java和Rust。但在实际应用中，没有理由说这个系统不能与任何语言配合工作。我的意思是，它只是一个LLM。系统中没有任何特定于语言或框架的内容。

对于你们当中的一些人，本周早些时候Tessle举办了一场会议，他们正在为知识库制定规范。只要你有正确的基础文档，他们的论点是，你在构建什么并不重要——这些都只是由你为系统构建的上下文所告知的。

参与者：这也是引导的一个非常好的要点。通过引导，你可以让代理按照你想要的方式开发代码。作为开发者就是要做权衡，而开箱即用的问题是它太礼貌了，因为它试图成为所有人的一切。特别是像延迟和成本等其他方面，只需要在引导中告诉它你希望它优先考虑什么，这将影响生成的任何代码。

演讲者：是的。甚至包括它如何基于此进行设计。所以如果有什么是你的用例或行业特别需要的，只需要把它放到引导文件中即可。

是的，这完全正确。例如，我会让Kira为我生成提交。我个人关心的一件事是，我可以跟踪我生成的提交与Kira生成的提交——那些来自系统的提交。所以我的引导文档虽然很短，但包含了一些非常具体的内容，比如我对Curo的要求是只使用UI，并归因于Kuro代理的共同作者。这很简单，但我希望每次都这样做。

在这种情况下，它就生成了一个由Kirao代理共同作者的提交。这是一个例子，你可以在那里添加任何你想要的内容，不仅仅是与git提交相关的内容，还可以是代码风格、代码覆盖率。每当你添加规范或添加新模块时，确保用90%的覆盖率最低要求来注释它，因为这是我关心的事情。你基本上可以在那里放任何你想要的东西。

好消息是，我们构建的东西看起来是有效的。Cur至少对自己很满意，看起来所有测试都通过了。我们可以将其部署到后端，看看效果如何。

我们在技术上刚好到时间了。如果有人还有其他问题，我会在这里待一会儿。但感谢大家的参与、聆听，以及更多地了解Spectrum和Dev Heat。

### (3:23 - 6:59) Spec驱动开发的核心理念
> 将传统软件开发生命周期与AI结合，通过需求→设计→实现的结构化流程提升代码质量

包括你的输入需求，实际进行设计和反馈，你知道，意识到"哦，实际上如果我们这样做，这里会有我们没有考虑到的副作用，我们需要将其反馈到输入需求中。"所以软件开发生命周期的这种压缩演变为在软件开发流程中引入结构。

我们想要采用作为设计一部分生成的工件，这些是产品经理或开发人员编写的需求，这将是验收标准——成功在最后看起来是什么样子。然后我们想要你可能与开发团队审查的设计工件，你可能与利益相关者审查并说这是我们要去构建和实现的东西，我们希望确保你可以在一些紧密的内循环中完成所有这些。

最终，这就是规格驱动开发最初的样子。

在Hero中，规格驱动开发今天的样子，或者至少在它变成通用版之前，是你给我们一个提示，我们会将其转换成一套清晰的需求和验收标准。我们用EARS格式表示这些验收标准。EARS代表需求语法的简单方法。这让你能够真正轻松地——它实际上是我们希望系统做什么的结构化自然语言表示。

在这个产品存在的前四个半月里，EARS格式看起来像是我们做出的一个有趣的决定，但只是有点有趣。随着我们在周一的全面可用性发布，我们终于开始推出一些副产品，其中之一就是基于属性的测试。

所以现在你的EARS需求可以直接转换为系统的属性，这些属性实际上是你想要交付的不变量。对于那些过去没有使用过基于属性测试的人，比如我想在Python中是hypothesis或者在node中是fast check，Closure的spec库是另一个例子。

这些是测试软件系统的方法，你实际上试图产生一个能够证伪你想要证明的不变量的单一测试用例。如果你能找到任何反例，那么你可以说这个需求没有得到满足。如果你找不到，你就对系统确实做了你说它做的事情有很高的信心度，其中"高"这个词承担了一点重负，因为这取决于你写测试的质量。

### (6:59 - 11:04) MCP集成与工具链优化基础
> 展示如何使用MCP服务器扩展Kuro能力，从外部系统获取上下文

我们稍后会更深入地讨论基于属性的测试和PBTs，但这是我们采取的许多步骤中的第一步，实际上将这些结构化自然语言需求与一直到完成代码的主线联系起来，并说如果你的代码的属性满足初始需求，我们就高度确信你已经可靠地交付了你期望交付的软件。

所以通过规格驱动开发，我们采用你的提示，将其转换为需求，从中提取设计，定义系统的属性，然后构建任务列表，你可以运行你的任务列表。实际上，规格就成为了你系统的自然语言表示。它有约束条件，它有关于功能需求、非功能需求的关注点，它是你要交付的这套工件。

我觉得我在这个演示文稿中没有这张幻灯片，但最终我看待规格的方式是，第一，它是一套代表你系统在时间点t状态的工件。第二，它是我们推动你通过的结构化工作流程，以可靠地交付高质量软件，包括需求、设计和执行阶段。第三，它是基于此的一套工具和系统，帮助我们交付可重现的结果，其中一个例子就是基于属性的测试。

另一个不太明显但我们稍后可以讨论的例子是我甚至不知道该怎么称呼它——需求验证。所以我们扫描你的需求以寻找过度的歧义性。我们扫描你的需求以寻找无效约束，比如你有冲突的需求，我们使用经典的自动推理技术帮助你解决这些歧义。

我可以更多地谈论Kira的特性。我认为这对于这次演讲来说可能不太有趣，因为我们想谈论规格驱动开发。不过我们有所有你期望的功能。我们有转向功能，这有点像记忆和光标规则。我们有MCP集成。我们有图像等等功能。我们有软件钩子。

所以让我们谈论一下如何完善你的工具链。我要在这里快速休息一下。暂停一下，对于房间里可能尝试过下载Kira或其他东西的人，在我们深入了解如何实际使用规格来实现目标之前，现在有任何问题吗？

没有问题。这可能是个好兆头。可能意味着我没有在谈论任何特别有趣的东西。

### (11:04 - 19:09) 自定义工件与流程优化
> 演示如何在spec中添加UI原型、测试用例等自定义内容，打磨工具链

所以我实际上想在这里谈论一些具体细节。这是我几个月前做的一个关于如何在Kira中使用MCPs的演讲。测试过Kira的人遇到的挑战之一，可能更容易看到的是，他们觉得我们推动他们通过的流程有点太结构化了，比如你无法访问外部数据，你无法访问你想要的所有其他东西。

所以在我们朝向... 哦你知道这里顺序错了，这是我的漂亮AI生成图像。所以你可以使用MCP。我假设这里的每个人现在都熟悉MCP。Kira集成MCP的方式与所有其他工具相同。但我认为人们做得不够的是在构建他们的规格时使用他们的MCPs。

所以你可以在规格驱动开发工作流程的任何阶段使用你的MCP服务器。包括需求生成、设计和实现。我们将通过每个阶段的示例。

首先，在Kiro中设置规格是相当简单的。我们这里有Kiro面板，有一个小幽灵，然后你可以下拉到你的MCP服务器并点击加号按钮。你也可以... 我最喜欢的方式是要求Kiro添加一个MCP，然后给它一些信息告诉它在哪里，它通常可以从那里找出来，或者你只需给它JSON blob，它就会找出来。

一旦你添加了MCP，你会在下面的控制面板中看到它，你可以启用它、禁用它、允许列表工具、禁用工具等。所以你可以通过这种方式管理上下文。

值得注意的是，更改MCP和一般更改工具是一个缓存操作。所以如果你深入到一个很长的会话中，也许不要调整你的MCP配置，因为它会显著减慢你的速度。

但让我们谈论MCP检查生成。所以Kiro团队使用的一个东西，出于我不知道的原因，但它是我们选择的任务跟踪器。

### (15:00 - 30:00) Part 2

好吧，也许我们可以在最后做现场演示。

这是你在 Kira 中能做的最基本的事情，就是使用 MCP 服务器，但任何工具都使用 MCP 服务器。我实际上不认为这特别有趣。假设在我们努力完善规范开发工具包的过程中，我们已经完成了 200 目砂纸的打磨。我们通过 MCP 添加了一些功能。这很有用，但对我们来说不会是游戏规则改变者。我想进入这里，实际升级到 400 目砂纸。让我们开始真正地把这个东西打磨得很好。我想定制产生的产物，因为你有这个任务列表，你有这个需求列表，但我不同意你在那里放的东西，AI。

你可能会说很多人都这样做，这是一个很好的起点。所以，这是我在本周早些时候听到的一些事情，在会议早期，人们喜欢在他们的模拟中使用线框图。使用线框模拟，因为在你的规范中是自然语言，你使用规范作为控制界面来解释你希望系统做什么。因此，我希望能够真正在这里放入 UI 模拟。所以简单的情况是，我进来说 Kuro 在这里问我设计看起来好吗？你满意吗？我说这看起来很棒，但你能否包含线框图并询问我们将在这里构建的屏幕。我正在添加这个，这又是来自那个高层次视图的东西。我正在添加一个用户管理 UI，但我想实际看到我们提议构建的东西，而不仅仅是事物的架构。

所以你的 Cure 将在这里坐几秒钟进行处理，但你可以向任何这些产物添加你想要的任何内容，因为它们是自然语言。所以它们是结构化的，这意味着我们希望在它们看起来如何方面有某种可重现性，但最终它们看起来如何并不重要，因为我们有这个机器，坐在那里的代理可以帮助将其转换为需要的样子。所以 Kira 在这里进行处理。它在思考，然后它将输出这些文本包装的 ASCII 图表。我稍后会在视频中修复包装，但最终你知道它做你想要的任何事情。

所以如果你想在你的需求中添加额外的数据，你可以做到。如果你想在设计中添加额外的数据，比如这样，你可以轻松添加。在这里，我们有这些 ASCII 格式的线框图，帮助我理解我们实际即将发布的内容。然后我可以继续聊天并说实际上在设计中我不想要，你知道，也许我不希望这个添加用户按钮一直在顶部，在这种情况下我可以与它聊天轻松做出那个改变，现在我们在前期就达成一致，而不是在实施时间期间。所以我们再次将一些关注点左移了。

### (19:09 - 36:26) 实战演示：Agent Core项目
> 通过真实项目展示spec驱动开发全流程，包括需求生成、设计和任务执行

这是一个例子。你知道，我想在系统设计中添加 UI 模拟。另一个例子虽然我实际上更喜欢一点的是这个在定义和任务中包含测试用例。所以今天 cure 给你的任务将是需求和你需要达到的接受标准的要点。但我想知道在这个任务被执行的最终状态下，我们有一个非常清晰的理解，它是正确的。它不仅仅是完成了，因为任何使用过代理的人都可能会证明 LLM 非常擅长说我完成了。我很高兴。我确定你很高兴。我只是要完成。哦，是的。测试没有通过，但它们很烦人。我尝试了三次让它们工作。我只是要继续前进。不，我不想要那个。我想实际知道事情在工作。

所以，在这种情况下，我已经要求 Hero 包含将被覆盖的明确单元测试用例。所以我这里的任务，例如创建这个代理核心内存检查指针，将有所有需要在完成之前通过的测试用例，然后我可以使用代理钩子等功能来确保这些是正确的。我们稍后会在演讲中运行这个样本。这是我准备做一点演示的东西。

是的，所以这是另一个例子，你再次在你的工具台上工作。你有所有这些在你控制下的功能和原语，你可以调整过程为你工作，而不仅仅是我认为是最好的过程。

然后最后但并非最不重要的，800 目砂纸。在这一点上，我们正在对工具进行最终抛光。我们可能在磨刀，但我们想要，你知道，你可以迭代你的产物，但你也可以迭代实际运行的过程。所以，一件你可能有的事情，我经常这样做，是我会与 Kira 聊天，我说："嘿，我想要，在这种情况下，我想要给我的代理核心中的代理添加内存。让我们在每次执行结束时将对话转储到 S3 文件。"Cur 会说："那很棒。我知道怎么做。我将研究确切如何做那件事。我将为你实现这个目标。"

但最终我所做的实际上是在前期引入了偏见，即我正在引导整个代理使用 S3 作为这个存储解决方案，只是因为也许我熟悉它，但这可能不是最好的方法。所以在它综合了设计和所有任务以及所有这些东西之后，我回来说好吧，我们不需要坚持这个由 Kirao 定义的严格的规范驱动开发工作流程。我可以要求替代方案，比如这是实现会话持久性的惯用方式吗？我不知道也许有更好的方式。也许如果我们谈论 AWS 服务，它不是 S3，而是 Dynamo 或等等。

Kira 会进入这里说，你知道，好问题。它会研究。它将调用我给它访问权限的一堆 MCP 工具。这有点回到你应该使用 MCP 的观点。然后它带着这个我不知道是一个功能的推荐回来，这是亚洲核心内存。它说这更惯用和面向未来，也许是 TBD 并且应该更仔细地检查。但你可以使用 S3，这是你推荐的东西。现在，实际上，我打赌这里有远远超过两个选项。所以，你可能可以继续询问代理，还有其他选项吗，等等，它会去继续调查，但你不应该把自己锁定在这里作为起点的严格流程中。

是的。所以，我认为这就是我幻灯片的内容。我要谈论的是让我们运行我刚才展示的那个样本，这是在 Curo 中的规范以及我们如何微调一些东西。所以这个项目是一个 Node.js 应用。它是一个 CDK。再次，我不是在试图推销更多的 AWS。这只是我熟悉的技术，所以我可以移动得更快。所以，我想了解一点代理核心，这是一个新的 AWS 产品。作为构建代理的人，我应该熟悉它。我对它不够熟悉。所以，我们有一些其他人在这里，他们对它了解很多。所以，举起我的手一点，你知道，你抓住了我。

所以，我设置了一个 CDK 堆栈，这只是我熟悉的部署软件的 IA 技术，我喜欢它。所以我有一个堆栈，让我部署任何代理核心运行时是什么。我不知道。我要求 Kira 做到这一点。我们 vibe 编码了这部分。所以我们 vibe 编码了通用结构。我们得到了一个代理。我们设置了 IA。然后我 vibe 代码添加了 commit lint。我添加了 husky。一些我为自己的 TypeScript 项目喜欢的东西。prettier 和 eslint 我想。所以我们在这里有一个基本产品或像一个基本项目，我知道我可以部署到我的个人 AWS 账户。

现在我要进入这里，然后重要的是，这非常重要，因为我不知道代理核心是如何工作的。我可以去读文档，但文档很长很复杂，我真的只是想构建一个 PC 来了解它。所以，我添加了两个 MCP 服务器。哦，不，也许我没有。让我检查。哦，好的。是的，抱歉。埋在这里底部。所以这是我的 Kira MCP 配置。我在这里添加了一个重要的 MCP 服务器，这是 AWS 文档服务器。有其他方式获取文档。你可以使用像 Tessle level 7 这样的东西，但在这种情况下，这是由 AWS 提供的。所以我有一些信心它可能是正确的。所以我使用这个来帮助代理了解存在什么技术。我想我也大量使用了 fetch。所以这些是我提供给系统的两套 MCP 服务器。很好。继续。

### (30:00 - 45:00) Part 3

不仅仅是我们如何做出关心的改变，而是关于系统功能的实际文档和规范。长期目标是，随着我们与 Kira 的合作，能够实现双向同步，也就是说，当你继续与 Kira 协作时，你不仅仅是在积累这些任务清单，而且如果我回来并在后续改变需求，我们会变更之前的规范。所以我看到的实际上是需求的差异比较，当你经历绿地开发过程时，你的 PR 中会产生很多绿色代码，这可能不是最好的，因为我只是在审查三个新的巨大 markdown 文件，但下次或后续我打开那个文档时，我希望看到的是你实际上放宽了这个之前的需求，你添加了一个对设计文档有影响的需求。

这就是 Curo 团队内部用来讨论 Curo 变更的流程。我们审查设计文档总体上已经被规范审查所取代。我们会有人从 markdown 中提取规范，使用内部的 MCP 工具基本上将其推送到我们的 wiki 中，然后我们在设计会议中审查和评论这个东西，而不是从头写 markdown 文件或 wiki。所以它变成了一种，实际上不像 ADR 因为它不是时间点记录，它像是关于系统的活文档。

这可能更多是频谱开发问题，但是否有像模板这样的一套文件供你填写？比如现在你在 design.md 中，是否有模板？这个 design.md 是规范吗，它是单个文档还是有多个？很好的问题。问题是是否有一套模板用于系统，你想问的是能否改变模板还是仅仅是否存在模板。是的，问题是是否有一套模板。在我们如何处理规范的系统提示中，确实有隐式的模板，你会在顶部导航栏看到，现在我们对需求设计任务列表阶段非常严格，但我们知道这不适用于所有人。

例如，如果你刚开始，我们从很多内部亚马逊员工那里得到反馈，他们说我想从一个技术设计的想法开始，我不一定知道需求是什么，但我知道我想制作，也许设计甚至是错误的词，我想从技术笔记开始。我想重构，这在重构中经常出现。所以我想重构这个以不再依赖于...这里有个好例子，我们在系统周围使用大量互斥锁来确保当代理执行某些操作时我们适当地锁定，因为我们不希望不同的代理相互干扰。但也许我想挑战系统的需求，这样我就可以移除其中一个互斥锁或者说信号量。

所以我可能从技术笔记之类的东西开始，然后从那里提取我想与团队分享的需求，说你知道，我必须稍微摸索一下才能理解我想构建什么，但我仍然希望生成所有这些丰富的工件。所以今天是这种结构化工作流程。我们在使其稍微更灵活方面做了很多尝试。但结构很重要，因为结构让我们能够构建可重现的工具，而不仅仅是一个 LLM。我认为这是我们做出的一个重要区别，我们的代理不仅仅是顶部有工作流程的 LLM。后端可能是也可能不是 LLM，或者在底层可能是也可能不是其他神经符号推理工具。

所以我们试图保持这种区别清晰，你不只是在与 Sonnet 或 Gemini 之类的对话。你在与基于你在任何时间点执行的任务类型的系统组合对话。虽然当你聊天时，你确实是在与 LLM 对话。但是，我们有需求的模板。我们有这个设计文档的模板，因为我们认为有些部分很重要。如果你不同意并且说我不在乎测试策略部分，就问代理去做，同样任务列表是结构化的，因为我们在其上也构建了 UI 元素，如任务管理。我们还会添加一些额外的 UI，比如可选任务等等，所以我们需要那里的结构才能使我们的任务 LSP 工作。

### (36:26 - 59:33) Q&A：深入探讨实践细节
> 回答关于大型代码库、上下文管理、AWS集成等实际应用问题

酷。在我们继续之前还有其他问题吗？我可能需要有人提醒我我们在做什么。对了，我们经历了为我的代理添加内存和一定持久性的规范综合。顺便说一下，我没有向你们介绍这个项目。这个项目叫 Gramps。它是我部署到 Agent Core 来了解它的代理。我提到过这个，但我没有告诉你们的是它是一个爸爸笑话生成器。一个非常昂贵的，因为我们通过 LLM 来驱动它，但实际上你是一个爸爸笑话生成器。笑话应该是干净的，应该基于双关语，显然如果稍微老套但讨人喜欢会有加分。

所以我们将这个部署到后端。我想要内存的原因是因为每次我向爸爸笑话生成器要笑话时，它给我同样的该死笑话，这太无聊了，我的孩子们不会对此感兴趣。所以我想要内存，这样当我在同一个会话中回来时，我会一遍又一遍地得到不同的笑话。这就是项目的背景。我们已经经历了这里，实际上我们说我们生成了这个东西，我们做了任务列表。我说："嘿，这是惯用的做法吗？"但我知道我们实际上没有使用 Agent Core 的内存功能，这可能是一个大错误。所以，快速举手表决。我们是想犯这个错误并一直到综合和部署，还是现在就修复它？

谁想现在修复它因为我们知道得更好？不，我想犯错误。让我们继续前进。我在满屋子什么都没有的情况下得到了三个赞成。所以我们要犯错误然后回来后面修复它。所以，让我们说按顺序运行所有任务。我提到按顺序的原因，这似乎很具体，是因为这是 Kira 的预览版本。所以有人刚刚在系统提示中添加了我应该一次只做一个任务。我发现如果我说运行所有任务，它认为我某种程度上意思是并行做它们。所以，在这些更改发布到生产环境之前，这会被修复。

所以 Kira 将继续在这里进行并在后端消化系统。它有解释如何做工作的指导文档。它有，我想我应该给你们展示。指导再次像是内存。所以我有一些关于如何做提交的指导，你知道，我喜欢如何有提交，但也有关于如何实际部署这个东西的指导，如何处理 Agent Core，然后如何运行将其部署到我的本地开发账户所需的命令。然后那些主要只是再次磨快你的工具的例子，我经历了这种痛苦的过程，弄清楚你必须在 CDK 命令上使用这个参数，你必须使用这个标志，否则它不能正确工作。

所以一旦我经历学习的痛苦，我就说 Kira 将你学到的写到指导文档中，它通常会在总结方面做得很好。所以它自动生成了这个 Agent Core LangGraph 工作流 MD 文件。是的，我的意思是它只是会在这里继续并完成它的工作，我们可以在后台观看它。但在此期间，我认为此时我们处于一个相当灵活的位置。对于想要的人，请随意使用 Kira，自己尝试规范驱动开发。我将继续在后台运行这个并回答问题和评论。但这就是今天安排部分的内容。

Curo 如何适用于现有的大型代码库？问题是 Curo 如何适用于大型和现有代码库，基本上是棕地用例，答案取决于你试图做什么。对于规范驱动开发，你可以要求 Curo 研究已经存在的内容，所以当你开始新规范时，它通常会通过读取工作树来开始，但代理通常是从零开始的角度开始的，它需要理解系统。在实践中，这意味着你会得到很多东西，如果你的系统已经有良好的关注点分离，你系统中的组件是高度内聚的，它们是高度一致和高度内聚的，它会做得很好。它能够说这是做这件事的模块，我不需要在我的上下文中保留 18 个东西来完成我的工作，它会做得很好。

### (45:00 - 1:00:00) Part 4

所以这并不是唯一的原因，我是说规范驱动开发的范围与性能关系不大，更多的是与代理的可重现性和准确性有关。因为如果我们能给你正确的结果，我们内部团队讨论这个问题的方式是：如果我花10秒钟给代理一个提示，然后它出错了，这对我来说没什么损失，对吧？我消耗了一些tokens，向LLM提供商花费了几分钱的使用费，但我只花了10秒钟生成提示。如果我花5到10分钟与系统一起制作详细的设计文档，或者说哪怕是一套详细的需求，我希望做得相当好。如果我花一个小时生成设计文档，与团队一起审查，然后从中综合，我希望做对。所以目标不仅仅是延迟，实际上是准确性。不，这是两者兼而有之。你需要同时做到两点。但规范更多来自于产生高度可重现输出的目标。

我先去这边，然后再回到你。

**参与者：** 是的。每个任务代理如何相互传递上下文？然后你是否只应该运行这个父任务？因为它刚刚完成了所有3.1、3.2、3.3任务，但然后它仍然认为3.1没有完成，并且在3.2中也运行了那个。

**演讲者：** 哦，是吗？

**参与者：** 是的。不过，我的理解是对的。

**演讲者：** 好的，是的。所以如果你在UI中运行任务，我可以拉起我的任务列表。如果我只是点击开始、开始、开始，每一个都将是一个新会话，这意味着上下文是完全独特的。个人来说，如果我有足够的上下文基础来负担得起，我喜欢说执行所有任务，因为我发现这样更容易理解，我认为我实际上会得到更好的性能。但默认情况下，每个任务都将是一个新会话，与之前的会话没有共享上下文。所以会话实际上只是以你的规范为种子，然后在这里你正在处理一个执行所有这些内容的规范，你正在执行这个任务，不要执行任何其他任务，只执行这个。这听起来像是个bug。

**参与者：** 它们是否为某些事情启动子代理？

**演讲者：** 我们在Curo中还没有子代理，我们正在开发这个功能。

**参与者：** 是的。因为我的意思是，理想情况下，对吧，如果我们点击任务三，我有31、32、33，并且它们是分开的，没有好的理由我不能让不同的系统处理它们。

**演讲者：** 在这里，我们在Curo CLI中确实有自定义代理，你也可以运行它们。

**参与者：** 是的。Curo CLI是自定义代理的概念，可以作为任务运行，这是我们现在在Curo Desktop中正在尝试的东西，我想你还有另一个问题。

**参与者：** 是的，对不起，如果我错过了这个，但在规范文件夹中，随着时间推移你执行越来越多的这些任务，这是否都在一个设计需求任务中，你的整个项目都在那里定义，还是它按组分组？

**演讲者：** 这是个好问题。是的，所以我会有很多，问题是随着时间推移你生成更多规范时。你是否只是创建一个巨大的规范？不是的。让我打开一个不同的项目。这就是例如Curo扩展，它就像Curo IDE内的一个第一方扩展。这是代理本身所在的地方。我们已经修剪了一些规范，但这里有一些我们可以讨论的规范，或者我可以演示。

我的思考方式是，规范代表项目中的一个功能或问题领域。例如，我可以把这个放大一点。我们有一些只是测试。我们做过一些事情，比如我们能否有一个提示注册表？我们能否有一个提示注册表文件加载器？它们可能会也可能不会一直走到生产环境。我想要聊天UI上的遥测。所以这些就像某人会去花费也许代表一个SD几天工作的东西。

代理MD支持是一个很好的例子，我们只是说研究什么是代理MD并以你构建steering支持的同样方式构建它。这个规范对我们来说在未来不太可能回来重新审视。所以我实际上可能会删除它，这就是我们对一些旧规范所做的。但我们可能会回来的一个好例子是我们的消息历史清理器。

我们遇到的一个问题，或者在Kira开发早期遇到的问题是，我们会发送这些无效的消息序列，因为比如说Anthropic API要求工具按照它们被调用的顺序和响应顺序排列，但系统没有这样做。所以我们构建了这整个清理器系统，它有一堆关于的需求。让我看看，非常具体地说，当对话被验证时，系统应验证每个用户输入要么是非空内容要么是工具响应。我们遇到过空字符串被传递但有工具响应的情况。这是一个很好的例子，我们随着时间推移回来，实际上只是添加到需求的验收标准中，因为发现了新的验证规则。

**参与者：** 是的。那么你如何处理这个？例如你有那里的遥测功能，需要遥测的功能是否会回去更新那个规范，还是你只是...

**演讲者：** 它应该会。是的。通常你会看到，让我在这里开始一个新的聊天。不，那是个糟糕的想法。

在这里我问了，我制作了一个检查模式，我请求添加UI遥测到这个东西，我会帮你添加它，让我首先检查是否有任何相关的运行手册，然后探索代码库并发送实现。它可能会在这里做一点研究，然后再次抛硬币，因为它是LLM，所以它可能会也可能不会发现现有的规范，但理想情况下它会在研究后说已经存在UI遥测等相关的规范，我将去修改那个。如果在这种情况下它没有发现，作为系统的操作者我会进来并要求它这样做。但随着时间推移，我们希望作为用户你不必考虑这么多，这变得更容易。

我们可以看着它慢慢进行。

**参与者：** Kira中是否有任何预配置的东西使它能更好地与AWS工作？

**演讲者：** 没有，不是真的。

**参与者：** 那是个问题吗？

**演讲者：** 哦，问题是Kira中是否有任何预配置的东西使它能更好地与AWS工作？没有。我们是有意为之的，我们是由AWS赞助的，所以你知道，Andy Jasse和Jeffy B发我的工资，但我们不是与AWS生态系统其他部分深度集成的AWS产品。话虽如此，当有人说"我们用AWS构建的其他东西为什么不能与Curo工作？"时，我仍然会回复邮件。但同样地，如果你在GCP或Azure上构建，无论什么，或者你运行一些本地系统，产品对你来说应该同样好用。这是我们的目标。

**参与者：** 一个好答案可能是AWS文档MCP服务器。

**演讲者：** 是的。有MCP服务器你可以添加到任何这些东西中，这会让它们更好。

是的，这是个好观点。在这种情况下，我实际上必须在这里添加AWS MCP文档。我们当然可以原生捆绑这个，但我不想把这个发送给不需要它的客户。

是的，因为同样，AWS不是我们可能关心的唯一文档。顺便说一下，回到你的问题，它确实找到了现有的遥测规范。它读了它，读了它的不同部分，现在它实际上在对其进行修改。所以我们可以跟踪这里显示的差异。它添加了新的需求到预先存在的规范中。所以这实际上是另一个我们正在改变系统的例子，而不是只是添加这种永无止境的规范流。

**参与者：** 我想知道的是，它如何知道或决定在哪里放置规范，你知道，如果你将项目分解成这些不同的类别？

**演讲者：** 我的意思是，这有点像软件开发的核心问题，对吧？你如何实际定义系统不同部分之间的接缝，不同的关注点？

**参与者：** 对，但如果你想构建需要改变三到四个东西的任务...

**演讲者：** 是的。

**参与者：** 它将改变三到四个规范，然后跨三到四个运行任务...

**演讲者：** 哦是的是的，不，它不应该那样做。它可能会...同样，我手头没有一个好的例子可以为此做演示，但我的观点是，如果你正在处理跨功能的东西，顺便说一下问题是，如果我正在处理比如说我有安全需求规范和API设计规范，比如API形状，我有日志规范，我正在更改API公共接口中的东西，这是一个面向安全的关注点，因为我们正在编辑日志PII，我想这可能是一个我们都能想象来自治理团队的半具体用例。

我想象你要么选择其中一个来加载需求，要么创建一种跨功能规范，但这将归结为我认为你作为操作者做出的决定，就像我如何实际实现它一样，你不一定会实现我的PII API编辑模块。它是一个独立的东西。我想象它会是贯穿你代码库的跨切主题。

这也是个好例子。多组工作空间在周一G大会上发布了，现在你可以拖拽不同的东西。在你刚才经历的例子中，比如API和身份验证，甚至前端，如果你有单独的项目，你可以引入这些项目，然后仍然工作。

**参与者：** 是的，谢谢兄弟。心理模型是规范生成代码，之后你可以指定什么代码，这是如何工作的？

**演讲者：** 是的，所以我们现在已经有效地综合了规范，我们坐下来定义了需求设计和任务列表，我让Kira现在去运行这个规范中的所有任务，所以它一次运行一个，基本上处理小块的工作，一块一块地进行，然后现在这完成了。所以我们实际产生的不只是完成的规范，它进入了我的代理，在CDK仓库中做了一些事情，因为它正在对S3进行持久化。我确定它添加了一个bucket。是的。一些新的bucket加密等等。然后它进入代理，添加了S3检查点保存器。看起来它创建了一个检查点器。它将这个添加到图中，并通过系统一直传递。这里的S3检查点器我确定知道如何向S3写入和从S3读取检查点。所以我们不仅定义了系统，我们现在端到端地产生了它，或者我们端到端地交付了它，包括属性测试我相信。

**参与者：** 哦，我有一个关于早期问题的答案，关于一些特定的AWS相关功能，让它更容易与之工作。Curo CLI带有使用AWS工具，这有助于CLI。

**演讲者：** 是的。所以Rob指出的是Curo CLI，我们本周刚刚重新品牌化，有一个使用AWS工具，基本上是AWS SDK的包装器，使其中一些事情变得容易。但同样，如果你倾向于使用GCP工具作为FCP服务器，如果那是你的工具选择。我相信，不要引用我的话，因为CLI对我来说是新的，我应该说。但我相信你也可以在CLI中关闭工具。如果这不对，请告诉我，Rob。

**参与者：** 是的。所以你实际上并不严格。在今天的桌面产品中，你不能控制工具，内置的原生工具，但在CLI中，你可以。

**参与者：** 所以我直觉上理解拥有规范的好处。你是否做过任何工作来经验性地看看一个项目或问题在有或没有规范的情况下如何工作？

**演讲者：** 是的。我们确实有基准测试涵盖数据。我想其中一部分在我们的博客中。所以如果你去curo.dev博客或者在网站上，我们非常清晰地谈论了一些提升，比如基于属性的测试给任务准确性带来的东西。科学团队总是在研究这些东西。

有一个关于规范的博客。我对此感到好奇。

**参与者：** 是的。数据库杰出工程师。是的。

**演讲者：** 他的博客文章真的很出色。我不认为它有你要求的具体D，但我认为这会有用。

**参与者：** 是的，是的。它如何工作？我理解功能方面，但它如何在非功能方面工作，比如代理处理更困难的问题？

**演讲者：** 嗯，是的。我的意思是，这最终就是这里的目标，对吧？我们是在说你前期投资稍微大一点，但我们相信我们带来的结构将帮助你增加结果的准确性。所以，虽然我们有一个团队基本上在努力让规范更好，当我飞回西雅图时，我的工作是让Curo整体变得更快。一方面是执行时间和UI中的延迟，另一方面是我们如何让tokens更快地通过系统？我们如何更快地给你响应，这样你就不会在使用规范时向KO投入那么多成本？

**参与者：** 是的，是的。我说的不是KO工具本身，而是从规范生成的代码。

### (1:00:00 - End) Part 5

### (59:33 - 1:03:48) 代码生成与测试验证
> 展示最终代码生成结果，包括属性测试和提交管理

演讲者：哦，哦，好的。是的，你是指生成代码的非功能性需求？这要取决于你具体想要做什么。你可以添加一些内容——我这里有一张幻灯片讲的是如何调整流程和调整工件以适应你的用例。你完全可以添加类似"我希望在设计阶段考虑速度、运行时以及锁竞争等非功能性需求"的要求。这是你肯定可以添加的功能。


---

*生成时间: 2026-01-10 03:33:42*
*由 YouTube Monitor & Translator (Claude CLI) 生成*