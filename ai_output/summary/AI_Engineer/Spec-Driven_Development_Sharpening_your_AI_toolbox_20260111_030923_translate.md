# Spec-Driven Development: Sharpening your AI toolbox - Al Harris, Amazon Kiro

## 📹 视频信息

- **频道**: AI Engineer
- **发布日期**: 2026-01-09
- **时长**: 1:03:51
- **原始链接**: [https://www.youtube.com/watch?v=HY_JyxAZsiE](https://www.youtube.com/watch?v=HY_JyxAZsiE)

---

本文内容整理自亚马逊 Kiro 首席工程师艾尔·哈里斯（Al Harris）在 AI Engineer 频道的技术分享。

---

## TL;DR（一句话核心洞察）

> Spec-Driven Development（规格驱动开发）通过将需求转化为结构化规范，结合属性基测试，让 AI 生成的代码质量和可靠性显著提升——从"振动编码"升级为"精确制造"。

---

## 📑 章节导航表

| 时间戳 | 章节标题 | 一句话概括 |
|--------|----------|-----------|
| 00:00-05:00 | Kiro 与 Spec-Driven 开发介绍 | 介绍 Kiro 作为 agentic IDE 的定位及规格驱动开发的核心理念 |
| 05:00-10:00 | 规格驱动开发工作流程 | 展示从需求到设计再到实现的结构化流程 |
| 10:00-20:00 | MCP 集成与工具链优化 | 演示如何通过 MCP 服务器增强 AI 开发能力 |
| 20:00-35:00 | 实战演示：Agent Core 项目 | 通过构建 AWS Agent Core 项目展示完整开发流程 |
| 35:00-50:00 | 规格管理与团队协作 | 讨论规格文档的版本管理和团队评审流程 |
| 50:00-64:00 | 深入技术细节与 Q&A | 回答关于大型代码库、性能优化、跨语言支持等问题 |

---

## 📊 核心论点

### Spec-Driven Development：从"振动编码"到精确工程

- **核心内容**：传统的 AI 编码依赖开发者不断给出正确的指令和护栏，就像"振动"一样充满不确定性。Spec-Driven Development 通过创建结构化的需求文档（EARS 格式）、设计文档和任务列表，将软件开发的 25-30 年最佳实践融入 AI 工作流。这种方法将迭代发生在需求和设计阶段，而非代码实现阶段，显著减少了返工。
- **关键概念**：EARS（Easy Approach to Requirements Syntax）、属性基测试、结构化工作流、需求验证、双向同步
- **实际意义**：企业级软件开发可以获得更高的可预测性和可靠性；减少 AI 生成代码的"幻觉"问题；让非技术人员也能参与需求评审；显著提升首次交付正确率。

### 属性基测试：从测试到证明的范式转变

- **核心内容**：传统单元测试只能验证特定输入输出，而属性基测试通过定义系统不变量（invariants），让测试框架自动生成大量边界案例来验证这些属性。Kiro 将 EARS 格式的需求直接转换为可执行的属性测试，建立了从需求到验证的完整链条。如果无法找到任何反例，就能以高置信度证明系统满足需求。
- **关键概念**：系统不变量、反例搜索、需求到测试的自动转换、Hypothesis/FastCheck、高置信度验证
- **实际意义**：大幅提升测试覆盖率和边界案例处理；减少生产环境 bug；让需求可以被自动验证；为合规和安全关键系统提供形式化保证。

### MCP 服务器：AI 开发的"外部大脑"

- **核心内容**：MCP（Model Context Protocol）服务器为 AI 提供外部数据访问能力。在 Kiro 中，MCP 可以在需求生成、设计和实现的任何阶段使用。例如，从 Asana 拉取任务生成需求，使用 AWS 文档 MCP 获取最新 API 信息，或通过 GitHub MCP 参考类似项目。这解决了 AI 模型知识截止和缺乏实时信息的问题。
- **关键概念**：外部数据集成、多阶段使用、文档访问、任务同步、实时信息获取
- **实际意义**：让 AI 能够访问企业内部文档和系统；保持生成代码与最新 API 的同步；自动化项目管理工具集成；减少因过时信息导致的错误。

### 活文档理念：规格作为"活着的真相"

- **核心内容**：与传统的 ADR（架构决策记录）不同，Kiro 的规格文档是"活的"——它们会随着系统演进而更新。当添加新功能时，系统会检查是否存在相关规格并进行修改，而非创建新文档。这种双向同步确保文档始终反映系统的真实状态，团队通过评审规格差异而非代码来理解变更。
- **关键概念**：双向同步、增量更新、规格评审、版本控制、需求追踪
- **实际意义**：解决了文档与代码脱节的历史难题；让新团队成员快速理解系统；支持更高效的代码评审；为监管合规提供完整的追踪链。

### 上下文管理的艺术：少即是多

- **核心内容**：Kiro 团队发现，给 AI 更少但更精确的上下文往往产生更好的结果。系统通过"增量披露"策略，让 AI 自主发现所需上下文，而非一开始就加载大量信息。通过提示缓存优化，可以达到 90-95% 的缓存命中率，显著提升响应速度。这种方法类似于人类专家的工作方式——先理解问题，再寻找相关信息。
- **关键概念**：增量披露、自主发现、提示缓存、上下文窗口管理、缓存优化
- **实际意义**：降低 AI 调用成本；提升响应速度；改善大型代码库的处理能力；让 AI 更像人类专家一样工作。

### 可定制的开发流程：工具服务于人，而非相反

- **核心内容**：虽然 Kiro 提供了需求→设计→实现的标准流程，但认识到不同团队和项目有不同需求。用户可以自定义每个阶段的产出物（如在设计中添加线框图），可以从技术笔记开始逆向推导需求，甚至可以通过 steering 文档定制代码风格、测试覆盖率要求等。系统的结构化不是为了限制，而是为了提供可重复、可定制的基础。
- **关键概念**：流程定制、模板修改、steering 文档、逆向工程、团队偏好
- **实际意义**：适应不同组织的开发文化；支持探索性开发和正式开发；让工具适应团队而非相反；保持灵活性的同时确保质量。

### 神经符号混合：超越纯 LLM 的架构

- **核心内容**：Kiro 明确定位不仅仅是"LLM + 工作流"，而是结合了经典自动推理技术的混合系统。系统会扫描需求中的歧义和冲突，使用形式化方法验证约束的有效性。这种方法借鉴了 25-30 年的软件工程经验，将确定性推理与概率性生成相结合，目标是逐步减少对 LLM 的依赖。
- **关键概念**：神经符号 AI、自动推理、需求验证、确定性方法、混合架构
- **实际意义**：提供更可靠的代码生成；减少 AI 幻觉；支持形式化验证；为安全关键应用铺平道路。

### 投资回报的权衡：前期投入换取长期收益

- **核心内容**：使用 Spec-Driven Development 需要更多前期投入——花 5-10 分钟编写详细需求，甚至一小时完成设计评审。但这种投入是值得的：10 秒的快速提示失败了只是浪费几分钱，而基于详细规格的开发能显著提升首次成功率。这种方法特别适合需要高可靠性、团队协作或长期维护的项目。
- **关键概念**：前期投资、准确性提升、团队协作成本、长期维护性、风险降低
- **实际意义**：帮助团队决定何时使用规格驱动开发；量化 AI 辅助开发的 ROI；支持企业级 AI 开发决策；平衡速度与质量。

### 多语言与框架无关：真正的通用性

- **核心内容**：虽然演示使用 Node.js，但 Kiro 和 Spec-Driven Development 本质上与语言无关。系统正式支持 Java、Python、JavaScript/TypeScript 和 Rust，但实际上可以用于任何语言。性能特性和最佳实践会根据目标语言自动调整，用户可以通过 steering 文档指定语言特定的偏好，如 Rust 的内存安全或 Java 的设计模式。
- **关键概念**：语言无关性、框架适配、性能调优、语言特定优化、跨平台支持
- **实际意义**：支持多语言企业环境；保护现有技术投资；支持逐步迁移策略；让团队使用熟悉的技术栈。

### 从单体规格到模块化架构：规格的组织艺术

- **核心内容**：大型项目不是创建一个巨大的规格文档，而是按功能或问题域创建多个规格。每个规格代表几天的开发工作，可以独立演进。跨功能需求（如安全、日志）可以创建专门的规格或在现有规格中引用。系统会自动检测相关规格并建议更新，支持规格间的依赖管理。
- **关键概念**：模块化规格、功能边界、跨切关注点、规格依赖、自动关联
- **实际意义**：支持大型团队并行开发；保持规格的可管理性；支持微服务架构；便于权限管理和代码所有权。

---

## 🏢 提及的公司/产品

| 公司名 | 讨论语境 | 重要性 |
|--------|----------|--------|
| Amazon Kiro | Spec-Driven Development 的实现者，演示的核心产品 | ⭐⭐⭐ |
| AWS (Agent Core, CDK, S3) | 云服务集成示例，展示企业级 AI 开发 | ⭐⭐⭐ |
| Cursor/Windsurf | 同类 AI IDE 产品，VS Code 分支竞品 | ⭐⭐ |
| Asana | 项目管理工具集成示例 | ⭐ |
| Anthropic | MCP 协议提供者 | ⭐ |

---

## 💬 经典金句

> "Vibe coding relies a lot on me as the operator getting things right. We wanted Spec-Driven Dev to respect what came before - 25-30 years of industry experience building software well."
> — Al Harris

> "If I spend 10 seconds giving a prompt and it fails, no big deal. If I spend an hour with my team reviewing a design doc, I want to get it right."
> — Al Harris

> "The spec is not just an artifact at a point in time - it's living documentation about the system."
> — Al Harris

> "We want to use classic automated reasoning techniques to give you high quality results, not just whatever the latest model tells you."
> — Al Harris

---

## 👤 主要人物

#### Al Harris（艾尔·哈里斯）

**身份**：亚马逊 Kiro 团队首席工程师
**背景**：在亚马逊负责开发 Kiro IDE，之前参与过 Q Developer 相关项目。拥有丰富的软件工程经验，特别是在开发工具和 AI 辅助编程领域。
**核心观点**：强调 AI 编程需要结构化方法而非"振动编码"；认为前期投入详细规格能显著提升代码质量；倡导将经典软件工程实践与 AI 能力结合；主张工具应该适应团队而非相反。

---

## 📺 视频类型判断

**演讲独白**：技术分享形式，包含大量现场演示和 Q&A 环节

---

## 📝 完整翻译

### (0:00 - 15:00) Part 1

**(0:00 - 1:15)**

对于那些没有听说过我们的人，Kira 是一个代理式集成开发环境。我们在最近的周一正式发布，我想是 17 号，但我们在 7 月进行了公开预览，我记得是 7 月 14 号。所以已经运行了几个月，收集客户反馈，所有这些好东西。我们今天要谈论如何使用规范驱动开发来提升你的 AI 工具箱。

我做了举手统计，大约四分之一的人熟悉规范驱动开发。我叫 Al Harris，亚马逊的首席工程师。我一直在开发 Kira。我们是一个非常小的团队，基本上就是三四个人坐在一个小房间里，做我们认为可以改善客户软件开发生命周期的事情。

**(1:15 - 2:30)**

我们负责构建一个开发工具，用来改善规范驱动开发的体验。理论上我们由支持 QDV 之类产品的组织资助，但我们有意成为一个与 QE 系统完全不同的产品套件，对这些事情采取不同的方法。

我们想要解决的是帮助你将 AI 开发扩展到更复杂的问题，提高你对 AI 代理的控制能力，改善代码质量，并保持从管道另一端输出结果的可靠性。我们的解决方案是规范驱动开发。我们研究了一些现有的工具，并说："嘿，氛围编程很好，但氛围编程很大程度上依赖于我作为操作者把事情做对。"

**(2:30 - 3:45)**

这意味着我要给系统提供护栏，我要让代理通过一个严格的工作流程。我们希望规范驱动开发能够代表整体的软件开发生命周期，因为我们有 25 到 30 年的行业经验，构建软件，构建得很好，并且使用不同的实践。我们经历过瀑布模型、极限编程，我们有所有这些不同的方式来表示系统应该做什么，我们希望有效地尊重以前的经验。

这个动画看起来好多了。最初只是左边的菱形，但想法是你基本上在一个想法上迭代。我认为软件开发的一半是发现需求。这种发现不仅仅是坐在那里思考系统应该做什么，系统能做什么。

**(3:45 - 5:00)**

在做这个工作的过程中，我们意识到让这些系统工作的最佳方式实际上是合成输出并能够非常快速地反馈。比如你的输入需求，实际做设计和反馈，你知道，意识到如果我们这样做，这里有一个我们没有考虑的副作用，我们需要将其反馈到输入需求中。

因此，SDLC 的这种压缩演变为在软件开发流程中引入结构。我们想要采用你作为设计的一部分生成的工件——这是产品经理或开发者编写的需求，这将是验收标准，成功在最后看起来是什么样子，然后我们想要你可能与开发团队审查的设计工件，你可能与利益相关者审查并说这是我们要去构建和实现的东西。我们希望确保你能在一些紧密的内循环中完成这一切。

**(5:00 - 6:15)**

最初规范驱动开发就是这样的。Kira 中现在的规范驱动开发，至少在正式发布前是这样的：你给我们一个提示，我们将其转化为一组明确的需求和验收标准。我们以 EARS 格式表示这些验收标准。EARS 代表需求语法的简单方法。这让你能够非常容易地——它实际上是我们希望系统做什么的结构化自然语言表示。

在这个产品存在的前四个半月里，EARS 格式看起来像是我们做出的一个有趣决定，但只是有点有趣。随着我们周一的正式发布，我们终于开始推出一些副作用，其中之一是基于属性的测试。

**(6:15 - 7:30)**

现在你的 EARS 需求可以直接转换为系统的属性，这些属性实际上是你想要交付的不变量。对于那些过去没有进行过基于属性的测试的人，使用 Python 中的 hypothesis 或 Node 中的 fast check，Closure 的 spec 库是另一个例子。这些是测试软件系统的方法，你实际上试图产生一个能够证伪你想要证明的不变量的单一测试用例。如果你能找到任何反例，那么你可以说这个需求没有得到满足。如果你不能，你就有一定的高置信度——这里的"高"一词承担了一点重任，因为这取决于你写测试的好坏——但你可以高度自信地说系统确实做了你说它做的事情。

**(7:30 - 8:45)**

我们稍后会更多地讨论基于属性的测试和 PBT，但这是我们采取的许多步骤中的第一步，实际上采用这些结构化自然语言需求，然后将其与一条主线绑定一直到完成的代码，并说如果你的代码，如果代码的属性满足初始需求，我们高度自信你已经可靠地交付了你期望交付的软件。

通过规范驱动开发，我们接受你的提示，将其转化为需求，从中提取设计，定义系统属性，然后我们构建任务列表，你可以运行你的任务列表。实际上，规范然后成为你系统的自然语言表示。它有约束，它有围绕功能需求、非功能需求的关注点，这是你正在交付的一组工件。

**(8:45 - 10:00)**

我不认为我在这个演示中有这张幻灯片，但最终我看规范的方式是：第一，它是一组代表你系统在时间点 t 状态的工件。第二，它是我们推动你通过的结构化工作流程，以可靠地交付高质量软件，那就是需求、设计和执行阶段。第三，它是在此基础上的一组工具和系统，帮助我们交付可重现的结果，其中一个例子就是基于属性的测试。

另一个不太明显但我们稍后可以讨论的例子将是需求验证。我们扫描你的需求以查找过度模糊性。我们扫描你的需求以查找无效约束，例如你有冲突的需求，我们使用经典的自动推理技术帮助你解决这些模糊性。

**(10:00 - 11:15)**

我可以更多地谈论 Kira 的功能。我认为对这次演讲来说这可能不太有趣，因为我们想谈论规范驱动开发。不过我们有所有你期望的东西。我们有方向控制，这有点像内存和光标规则。我们有 MCP 集成。我们有图像等等。我们有软件钩子。

让我们谈论一下如何提升你的工具链。我想在这里快速休息一下。为了房间里那些可能尝试过下载 Kira 或其他东西的人暂停一下，问一下在我们深入讨论如何实际使用规范来实现目标之前，现在有什么问题吗？

没有问题。这可能是个好兆头，也可能意味着我没有谈论任何特别有趣的东西。

**(11:15 - 12:30)**

我实际上想在这里谈论一些具体的细节。这是我几个月前关于如何在 Kira 中使用 MCP 的演讲。测试过 Kira 的人遇到的挑战之一，可能更容易看到的是，他们觉得我们推动他们通过的流程有点过于结构化，比如你没有访问外部数据的权限，你没有访问你想要的所有其他东西。

在我们朝着这个方向前进的过程中，我们说的一件事——哦，你知道这个顺序是错的，这是我漂亮的 AI 生成图像。你可以使用 MCP。我假设这里的每个人此时都熟悉 MCP。Kira 集成 MCP 的方式与所有其他工具相同。

**(12:30 - 13:45)**

但我认为人们做得不够的是在构建规范时使用他们的 MCP。你可以在规范驱动开发工作流程的任何阶段使用你的 MCP 服务器，包括需求生成、设计和实现。我们将通过每个的例子来介绍。

首先，在 Kira 中设置规范是相当简单的。我们这里有 Kira 面板，有一个小幽灵，然后你可以去你的 MCP 服务器并点击加号按钮。你也可以——我最喜欢的方式是让 Kira 添加一个 MCP，然后给它一些关于它在哪里的信息，它通常可以从那里找出来，或者你只是给它 JSON 块，它会找出来。

**(13:45 - 15:00)**

一旦你添加了 MCP，你会在这里的控制面板中看到它，你可以启用它、禁用它、允许列表工具、禁用工具等。所以你可以通过这种方式管理上下文。值得注意的是，更改 MCP 和一般更改工具是缓存操作。如果你在一个很长的会话中很深入，也许不要调整你的 MCP 配置，因为这会显著拖慢你的速度。

但让我们谈论 MCP 规范生成。Kira 团队出于我不知道的原因使用 Asana，但这是我们选择的任务跟踪器。我想做的一件事是也许去说我不想从头开始为规范编写需求。我的产品团队已经做过一些思考。我们在 Asana 中迭代，将项目分解。这并不总是事情的运作方式，但有时是这样运作的。

### (15:00 - 30:00) Part 2

**(15:00 - 16:15)**

也许我们会在最后做现场演示。

这基本上是你可以用 Kira 做的最基本的事情 - 就是使用 MCP 服务器，但任何工具都使用 MCP 服务器。我实际上不认为这特别有趣。假设在我们努力完善规范驱动开发工具包的过程中，我们已经完成了 200 目砂纸的阶段。我们通过 MCP 添加了一些功能。这很有用，但对我们来说不会是游戏规则改变者。我想进入这里，实际上达到 400 目砂纸的效果。让我们开始给这个东西打磨出真正好的光泽。

**(16:15 - 17:30)**

我想自定义产生的制品，因为你有这个任务列表，你有这个需求列表，但我不同意你放在那里的东西，AI。你可以说很多人都这样做，我认为这是一个很好的起点。这是我本周早些时候在会议上听到的，人们喜欢在他们的原型中使用线框图。使用线框原型是因为在你的规范是自然语言的情况下，你使用规范作为控制面来解释你希望系统做什么。因此我希望能够实际在这里放入 UI 原型。

**(17:30 - 18:45)**

最简单的情况是我进入这里，Kira 问我设计看起来好吗？你满意吗？我说这看起来很棒，但你能包含线框图并要求我们将要构建的屏幕吗？我正在添加这个 - 再次来自那个宏观视图的东西。我正在添加一个用户管理 UI，但我想实际看到我们正在提议构建什么，而不仅仅是这个东西的架构。

所以 Kira 会在这里运转几秒钟，但你可以向任何这些制品添加你想要的任何内容，因为它们是自然语言。所以它们是结构化的，这意味着我们希望它们看起来有某种可重现性，但最终它们看起来如何并不重要，因为我们有这个 AI 机器，这个代理坐在那里可以帮助将其翻译成需要的样子。

**(18:45 - 20:00)**

所以 Kira 在这里运转着。它在思考，然后它会输出这些文本包装的 ASCII 图表。我稍后会在视频中修复包装问题，但最终它会做你想要的任何事情。所以如果你想在需求中添加额外的数据，你可以这样做。如果你想在设计中添加额外的数据，像这样，你可以轻松添加。

这里我们有这些 ASCII 格式的线框图，帮助我理解我们实际上即将发布什么。然后我可以再次继续聊天并说，实际上在设计中我不想要，你知道，也许我不希望这个添加用户按钮一直在顶部，在这种情况下我可以与它聊天来轻松进行更改，现在我们在前期就达成一致，而不是在后期实施时才发现问题。

**(20:00 - 21:15)**

所以我们再次将一些关注点左移了。这是一个例子。你知道，我想在系统设计中添加 UI 原型。但另一个我实际上更喜欢的例子是在定义和任务中包含测试用例。

所以今天 Kira 给你的任务会是需求的要点和你需要达到的接受标准。但我想知道在这个任务执行的最终状态，我们对它是正确的有一个非常清晰的理解。它不仅仅是完成了，因为任何使用过代理的人都可能证明 LLM 非常擅长说我完成了。我很满意。我确信你也满意。我就要完成了。哦，是的，测试不通过，但它们很烦人。我尝试了三次让它们工作。我就要继续了。

**(21:15 - 22:30)**

不，我不想要那样。我想实际知道事情是有效的。所以在这种情况下，我已经要求 Kira 包含将被覆盖的明确单元测试用例。所以我这里的任务，例如在创建这个代理核心记忆检查指针时，将拥有在完成之前需要通过的所有测试用例，然后我可以使用代理钩子之类的东西来确保这些是正确的。我们稍后会在演讲中运行这个示例。这是我准备稍微演示的东西。

是的，这是另一个例子，再次你在工作台上工作。你拥有所有这些能力和原语在你的控制之下，你可以调整流程为你工作，而不仅仅是我认为最好的流程。

**(22:30 - 23:45)**

然后最后但同样重要的是，800 目砂纸。在这一点上，我们正在给工具进行最后的抛光。我们可能在精修刀刃，但我们想要的是，你知道，你可以迭代你的制品，但你也可以迭代实际运行的流程。

所以，你可能有的一件事，我经常这样做，是我会与 Kira 聊天，我说："嘿，我想要在这种情况下，我想要给我的代理核心中的代理添加内存。让我们在每次执行结束时将对话转储到 S3 文件。"Kira 会说："太好了。我知道怎么做。我要研究究竟如何做那件事。我会为你实现这个目标。"

**(23:45 - 25:00)**

但最终我实际做的是在前期引入了偏见，我正在使用 S3 作为存储解决方案来引导整个代理，仅仅因为也许我对它熟悉，但这可能不是最好的方法。所以在它综合了设计和所有任务和所有这些东西之后，我回来说，好吧，我们不需要坚持这个由 Kira 定义的严格的规范驱动开发工作流程。我可以要求替代方案，比如这是实现会话持久性的惯用方法吗？我不知道，也许有更好的方法。也许如果我们在谈论 AWS 服务，它不是 S3，而是 Dynamo 或其他什么。

Kira 会进入这里并说，你知道，好问题。然后让我研究一下。它会调用一堆我给它访问权限的 MCP 工具。这有点回到你应该使用 MCP 的观点。

**(25:00 - 26:15)**

然后它带着我不知道是一个功能的推荐回来，那就是代理核心记忆。它说这更符合惯例并且更具未来性，也许这有待确定，应该更仔细地检查。但或者你可以使用 S3，这是你推荐的东西。现在，实际上，我打赌这里有远不止两个选项。所以，你可能可以继续问代理，还有其他选项吗，等等，它会继续调查，但你不应该将自己锁定在这里作为起点的严格流程中。

是的。所以那实际上我认为是我演示的结尾。我要谈论的是让我们运行一下我刚才展示的示例，基本上让我删除它，我只是做一个关于 Kira 中规范的现场演示以及我们如何微调一些东西。

**(26:15 - 27:30)**

所以这个项目是一个 Node.js 应用程序。它是一个 CDK。再次，我不是试图销售更多的 AWS。这只是我熟悉的技术，所以我可以移动得更快。所以，我想了解一点代理核心，这是一个新的 AWS 产品。作为一个构建代理的人，我应该熟悉它。但我对它不够熟悉。所以，我们有一些其他人在这里，他们对此了解很多。所以，举起我的手，你知道，你抓住我了。

所以，我设置了一个 CDK 栈，这只是一种部署软件的技术。我熟悉它并且我喜欢它。所以我这里有一个栈，让我部署任何代理核心运行时是什么。我不知道。我让 Kira 做它。我们氛围编码了这部分。

**(27:30 - 28:45)**

所以我们氛围编码了一般结构。我们有一个代理。我们设置了基础架构。然后我氛围编码添加了 commit lint。我添加了 husky。一些像这样我喜欢为我自己的 TypeScript 项目做的事情。prettier 和 eslint 我想。所以我们这里有一个基本的产品或像一个基本的项目，我知道我可以部署到我的个人 AWS 账户。

现在我要进入这里，然后重要的是，这非常重要，因为我不知道代理核心是如何工作的。我可以去读文档，但文档很长很复杂，我真的只是试图构建一个 POC 来自己学习它。所以，我添加了两个 MCP 服务器。哦，不，也许我没有。让我检查一下。

**(28:45 - 30:00)**

哦，好的。是的，抱歉。埋在这里底部。所以这是我的 Kira MCP 配置。我在这里添加了一个重要的 MCP 服务器，那就是 AWS 文档服务器。有其他获取文档的方法。你可以使用像 Tessle level 7 之类的东西，但在这种情况下这是由 AWS 提供的。所以我有一些信心它可能是正确的。所以我使用这个来帮助代理了解存在什么技术。我想我也大量使用了 fetch。

所以这些是我提供给系统的两套 MCP 服务器。很好。继续。确认。所以我只是从头开始重新运行这个。所以我昨天晚上或者也许前天晚上做的是我坐下来，我有这个系统基本工作，现在我想开始做规范驱动开发。

### (30:00 - 45:00) Part 3

**(30:00 - 31:15)**

这不仅仅是我们如何做出我们关心的改变，它实际上是关于系统功能的文档和规范。我的长期目标是，通过 Kira，我们能够实现某种双向同步。也就是说，当你继续使用 Kira 时，你不仅仅是在积累这些任务列表，我现在就去看看任务。我们不仅仅是在积累任务列表，实际上，如果我回来并且说在后续过程中改变需求，我们会修改之前的规范。

**(31:15 - 32:30)**

所以我实际上只是在看需求的差异。当你进行绿地开发过程时，你的 PR 中会产生大量的绿色代码，这可能不是最好的，因为我只是在审查三个全新的巨大 Markdown 文件。但是下次或后续几次当我打开那个文档时，我希望看到的是，哦，你实际上放宽了之前的这个需求，你添加了一个实际上对设计文档有这种影响的需求。这就是 Curo 团队内部用来讨论 Curo 变更的流程。

**(32:30 - 33:45)**

我们审查设计文档总的来说已经被规范审查所取代。所以我们会让某个人从 Markdown 中提取一个规范，他们基本上会使用我们内部使用的 MCP 工具将其放到我们的 wiki 中，然后我们会审查那个东西并在某种设计会议中对其进行评论，而不是说我从头开始写了这个 Markdown 文件或 wiki。所以它变成了某种，嗯，实际上它不像 ADR，因为它不是时间点的。它更像是关于系统的活文档。但是，谢谢你的问题。这里还有一个问题。

**(33:45 - 35:00)**

这可能更多是一个频谱开发问题，但是否有像模板这样的一套文件供你填写？就像现在你在 design.md 中。是否有像，这个 design.md 是规范吗，它是一个单一的文档还是有多个？

很好的问题。所以问题是，如果我理解正确的话，问题是是否有一套用于系统的模板，你想问的是你能否改变模板，还是只是问是否存在这样的模板？好的，所以问题是是否有一套模板。

**(35:00 - 36:15)**

在我们的系统提示中隐含地存在关于我们如何处理你的规范的模板，所以你会在这里的顶部导航栏中看到，现在我们对这个需求设计任务列表阶段非常严格，但我们知道这不适用于每个人。例如，如果你刚开始，我们从很多内部亚马逊员工那里得到这样的反馈，即我想从一个技术设计的想法开始，我不一定知道需求是什么，但我知道我想做，也许设计甚至不是正确的词，我想从一个技术笔记开始。

**(36:15 - 37:30)**

就像我想重构，这在重构中经常出现。所以我想重构这个，使其不再依赖于。这里有一个很好的例子，我们在整个系统中使用大量的互斥锁来确保当代理执行某些动作时我们适当地锁定，因为我们不希望不同的代理相互干扰。但也许我想挑战系统的需求，这样我就可以移除其中一个互斥锁，呃，或者应该说信号量。

**(37:30 - 38:45)**

所以我可能会从技术笔记之类的东西开始，然后从那里提取我想与团队分享的需求，并说，嘿，你知道，我必须稍微摸索一下才能理解我想要构建什么，但我仍然想生成所有这些丰富的产品。所以今天它是这种结构化的工作流程。我们在让它更加灵活方面做了很多尝试。但是结构很重要，因为结构让我们能够构建可重复的工具，这不仅仅是一个LLM。

**(38:45 - 40:00)**

所以我认为这是我们做出的一个重要区别，即我们的代理不仅仅是一个在其顶部有工作流程的 LLM。后端可能是也可能不是 LLM，或者它可能是也可能不是引擎盖下的其他神经符号推理工具。所以我们试图保持这种区别有点清楚，你不仅仅是在与 Sonnet 或 Gemini 或其他什么交谈。你实际上是在与基于你在任何时间点执行的任务类型的系统集合进行交谈。尽管当你在聊天时，你确实只是在与一个 LLM 交谈。

**(40:00 - 41:15)**

但是，是的，我们有需求的模板。我们有这个设计文档的模板，因为有一些我们认为重要的部分需要覆盖。再次，如果你不同意并且你说我不关心测试策略部分，就让代理去做。类似地，任务列表是结构化的，因为我们也在其上构建了一些 UI 元素，比如任务管理。我们稍后会讲到一些基于属性的测试时会涉及到，但是我们会为可选任务等添加一些额外的 UI，所以我们需要那里的结构来让我们的任务列表 LSP 工作。

**(41:15 - 42:30)**

谢谢你的问题。在我们继续之前还有什么问题吗？

好的。我可能需要有人提醒我我们在做什么。哦，对了。所以，我们完成了并且综合了为我的代理添加内存和一些持久性的规范。顺便说一下，我没有向你们介绍这个项目。这个项目叫做 Gramps。它是一个我部署到 Agent Core 来了解它的代理。我提到过这个。但我没有告诉你们的是，它是一个冷笑话生成器。

**(42:30 - 43:45)**

一个非常昂贵的，因为我们通过 LLM 为其提供动力，但实际上你是一个冷笑话生成器。笑话应该是干净的。它们应该基于双关语，你知道，显然如果它们稍微陈腐但讨人喜欢的话会有额外的分数。诸如此类。所以我们正在将其部署到后端。所以，我想要内存的原因是因为每次我向冷笑话生成器要一个笑话时，它给我同一个该死的笑话，这太无聊了，我的孩子们不会对此感到兴奋。所以，我想要内存，这样当我回到同一个会话时，我会一遍又一遍地得到不同的笑话。这就是项目的背景。

**(43:45 - 45:00)**

所以，我们已经完成了这里，我们实际上生成了这个东西，我们做了任务列表。我说，"嘿，这是惯用的做法吗？"但我知道我们实际上没有使用 Agent Core 的内存功能，这可能是一个大疏忽。所以，你知道，快速举手。我们是想犯错误并一路进行到综合和部署，还是应该现在就修复它？

谁想现在就修复它，因为我们知道得更好？

不，我想犯错误。让我们继续前进。我在一个满屋子人中得到了三个赞成。所以，我们要犯错误，然后回来稍后修复它。所以，让我们说按顺序运行所有任务。

### (45:00 - 1:00:00) Part 4

**(45:00 - 46:20)**

所以这并不是唯一的原因。我的意思是，Spec 模式的核心其实与性能关系不大，更多的是关于 Agent 的可重现性和准确性。因为如果我们能给你正确的结果...我们团队内部讨论这个问题的方式是：如果我花 10 秒钟给 Agent 一个提示，然后它出去搞砸了，对我来说基本上没什么损失，对吧？我烧掉了一些 Token，花费了几美分的 LLM 供应商费用，但我只花了 10 秒钟生成提示。

但如果我花 5 到 10 分钟与系统协作生成详细的设计文档，或者说哪怕只是一套详细的需求，我希望能做得相当好。如果我花一个小时生成设计文档、与团队审查，然后从中综合信息，我希望能做对。所以我们讨论的目标不仅仅是延迟，实际上是准确性。不，这是两者兼顾。你需要同时做到。但 Spec 更多来源于获得高度可重现输出的目标。

**(46:20 - 47:35)**

我先过来这边，然后你...

**观众：** 是的。这些任务 Agent 是如何相互传递上下文的？然后你是否只应该运行这个父任务？因为它刚刚完成了 3.1、3.2、3.3，但然后它仍然认为 3.1 没有完成，又在 3.2 中运行了一次。

**演讲者：** 哦，是吗？

**观众：** 是的。嗯，不，我的是对的。

**演讲者：** 哦，好的。是的，是的。问题是如果你在 UI 中运行任务，我可以拉出我的任务列表。如果我点击开始、开始、开始，每一个都将是一个新的会话，这意味着上下文是完全独立的。

就我个人而言，如果我有足够的上下文基础来支持，我喜欢直接说执行所有任务，因为我发现这样更容易理解，我认为我实际上能获得更好的性能。但默认情况下，每个任务将是一个新的会话，与之前的任务没有共享上下文。所以会话实际上只是用你的规范作为种子，然后就像这里你正在处理一个做所有这些东西的规范，你在做这个任务...不要做任何其他任务，只做这个。听起来像是个 bug。

**(47:35 - 48:50)**

**观众：** 它们会为某些事情启动子 Agent 吗？

**演讲者：** 我们在 Curo 中还没有子 Agent，正在开发中。

**观众：** 是的。因为我的意思是，理想情况下，对吧，如果我们点击任务三，我有 3.1、3.2、3.3，它们是分开的，没有什么好的理由我不能让不同的系统在它们上面工作。

**演讲者：** 就在这里，我们在 Curo CLI 中确实有自定义 Agent，你也可以运行。

Curo CLI 有自定义 Agent 的概念，可以作为任务运行，这是我们现在在 Curo Desktop 中正在试验的东西。我想你还有另一个问题？

**(48:50 - 50:15)**

**观众：** 是的，抱歉如果我错过了这个，但在 spec 文件夹中...随着时间推移你做越来越多这些任务...它是全部在一个设计需求任务中，你的整个项目都在那里定义，还是按组分组？

**演讲者：** 这是个好问题。是的，我会有很多...问题是随着时间推移你生成更多规范，你是创建一个大型规范，还是分组？不是的。让我打开一个不同的项目。

这是例如 Curo 扩展，就像 Curo IDE 内部的第一方扩展。这是 Agent 本身所在的地方。我们修剪了一些规范，但这里有一些规范我们可以讨论，或者我可以演示一下。

我的想法是，规范代表项目中的一个功能或问题领域。比如，我可以把这个放大一点。我们有一些只是测试的东西。我们做过像"我们能有一个 prompt 注册表吗？我们能有一个 prompt 注册表文件加载器吗？"之类的事情。它们可能会也可能不会一直推进到生产环境。我想要聊天 UI 上的遥测。所以这些就像某人会去花费的工作，可能代表一个软件工程师几天的工作。

**(50:15 - 51:30)**

Agent MD 支持是个好例子，我只是说研究一下什么是 Agent MD，然后以你构建转向支持的同样方式构建它。这个规范对我们来说在未来回来重新审视的可能性相当小。所以我实际上可能会删除它，这就是我们对一些较旧规范所做的。

但一个我们可能会回来的好例子是我们的消息历史清理器。Curo 开发早期我们遇到的一个问题是，我们会发送这些无效的消息序列，因为比如说 Anthropic API 要求工具与响应的调用顺序相同，但系统没有做到这一点。所以我们构建了整个清理器系统，它有一堆需求...

让我看看，非常具体地...是的，当对话被验证时，系统应该验证每个用户输入要么是非空内容要么是工具响应。我们遇到过空字符串被传入但有工具响应的情况。这是个好例子，我们随着时间推移回来，实际上只是添加了，可能不是添加到需求中，而是添加到需求的验收标准中，当发现新的验证规则时。

**(51:30 - 52:45)**

**观众：** 是的。那么你如何处理这样的情况？比如你那里有遥测功能，需要遥测的功能是会回去更新那个规范，还是你只是...

**演讲者：** 应该会的。是的。通常你会看到，让我在这里开始一个新的聊天。

不，这是个糟糕的想法。

这里我提出了一个请求，添加 UI 遥测到这个东西。它会帮助我添加它，让我首先检查是否有任何相关的运行手册，然后探索代码库并发送实现。它可能会在这里做一些研究，然后再次投硬币 - 因为它是 LLM，所以它可能会也可能不会发现现有的规范，但理想情况下它会在做完研究后说已经存在一个关于 UI 遥测之类的规范，我会去修改那个。如果它没有，在这种情况下，我作为系统操作员会进来要求它这样做。但随着时间推移，我们希望这对你作为用户来说更容易，不必考虑那么多。

我们可以看着它运行。

**(52:45 - 54:00)**

**观众：** Curo 中有什么预配置的东西让它更好地与 AWS 协作吗？

**演讲者：** 不，没有真的。

**观众：** 那是个问题吗？

**演讲者：** 哦，问题是，Curo 中有什么预配置的东西让它与 AWS 工作得更好吗？没有。我们是有目的的...我们由 AWS 赞助，所以你知道，Andy Jassy 和 Jeff Bezos 付我工资，但我们不像是与 AWS 生态系统深度深度集成的 AWS 产品。

话虽如此，当有人说"我们用 AWS 构建的这个其他东西为什么不能与 Curo 协作？"时，我仍然会回复邮件。但同样地，如果你在 GCP 或 Azure 上构建，或者你运行一些本地系统，产品对你来说应该同样好用。这是我们的目标。

一个可能的好答案是 AWS 文档 MCP 服务器。

是的。有 MCP 服务器可以添加到任何这些东西中，这会让它们更好。

**(54:00 - 55:15)**

是的，这是个好观点。在这种情况下，我实际上必须在这里添加 AWS MCP 文档。我们当然可以原生地捆绑这个，但我不想把它发送给不需要它的客户。

是的，因为 AWS 不是我们可能关心的唯一文档。顺便说一下，回到你的问题，它确实找到了现有的遥测规范。它读取了它，读取了不同的部分，现在实际上正在对它进行修改。我们可以跟随这里显示的差异。它向预先存在的规范添加了新的需求。所以，这实际上是另一个我们正在改变系统而不是只是添加这种永无止境的规范列表的案例。

**观众：** 我想知道的是它如何知道或决定在哪里放置规范，你知道，如果你把你的项目分解成这些不同的类别？

**演讲者：** 是的。

**观众：** 我想象会有交叉。

**演讲者：** 是的。我是说，这有点像软件开发的精髓，对吧？你如何实际定义系统不同部分之间的接缝，不同的关注点...

**(55:15 - 56:30)**

**观众：** 对，但如果你想构建某些东西，比如我有一个任务，它需要改变三四个东西...

**演讲者：** 是的。

**观众：** 它会改变三四个规范，然后跨三四个运行任务...

**演讲者：** 哦是的是的，不，它不应该那样做。可能...我手头没有一个好例子可以演示，但我的观点是，如果你正在处理跨功能的东西...顺便说一下，问题是如果我正在处理某些东西，比如说我有一个安全需求规范，我有一个 API 设计规范，比如 API 形状，我有一个日志规范，我正在改变 API 公共接口中的某些东西，这是一个面向安全的关注点，因为我们正在编辑日志 PII...我认为这可能是一个我们都能想象从治理团队那里得到的半具体用例。

我想象你要么选择其中一个来加载需求，要么创建一种跨功能规范，但这取决于你作为操作员做出的决定，就像如果我实际实现它的方式一样，你不一定会实现我的 PII API 编辑模块。它是一个独立的东西。我想象它将是贯穿你代码库的交叉主题。这也是个好例子。

**(56:30 - 57:45)**

周一发布了多组工作空间，现在你可以拖拽不同的...在你刚才经历的例子中，比如 API 和认证甚至前端，如果你把它们分别放在项目中，你可以引入这些项目然后仍然工作。

**观众：** 是的。谢谢兄弟。

心理模型是规范生成代码，在那之后你可以指定什么代码，这是如何工作的？

**演讲者：** 是的。我们现在已经有效地综合了规范，所以我们坐下来定义了需求设计和任务列表。我让 Curo 现在去运行这个规范中的所有任务，所以它一个一个地运行它们，它基本上一块一块地处理小的可消化的工作块，然后现在这完成了。

我们实际产生的不仅仅是完成的规范，它进入了我的 Agent，在 CDK 仓库中做了一些事情，因为它正在对 S3 进行持久化。我确信它添加了一个桶。是的。一些新的桶加密等等。然后它进入 Agent，添加了 S3 检查点保存器。看起来它创建了一个检查点器。它将这个添加到图中，并将其一路传递到系统中。这里的 S3 检查点器我确信具有如何向 S3 写入和从 S3 读取检查点的知识。

**(57:45 - 59:00)**

所以我们不仅定义了系统，我们现在端到端地产生了它，或者我们端到端地交付了它，包括属性测试，我相信。

**观众：** 哦，我有一个关于早期问题的答案，关于一些特定的 AWS 相关功能，让它更容易与 AWS 协作。Curo CLI 带有使用 AWS 工具，这有助于 CLI。

**演讲者：** 是的。是的。Rob 指出的是 Curo CLI，我们刚刚在这周重新品牌化，有一个使用 AWS 工具，基本上是 AWS SDK 的包装器，让其中一些事情变得简单。但同样，如果那是你选择的工具，带来你自己的使用 GCP 工具作为 MCP 服务器。我相信，不要引用我的话，因为 CLI 对我来说是新的，应该这么说。但我相信你也可以在 CLI 中关闭工具。如果我说错了，Rob，请告诉我。

**观众：** 是的。所以，那就像你实际上不是严格的。在今天的桌面产品中，你无法控制工具，内置的原生工具，但在 CLI 中，你可以。

**(59:00 - 1:00:00)**

我直觉上理解拥有规范的好处。你是否做过任何工作来实证地看一个项目或问题在有或没有规范的情况下会如何工作？

是的。我们确实有涵盖数据的基准测试。我认为其中一部分在我们的博客中。如果你去 curo.dev/blog 或者在网站上，我们非常清晰地讨论了像基于属性的测试给任务准确性带来的一些提升。科学团队总是在研究这些东西。

有一篇关于规范的博客。我很好奇...

是的。数据库杰出工程师。是的。

他的博客文章真的很出色。我不认为它有你问的具体数据，但我认为会很有用。

是的。是的。

它是如何工作的？我理解功能方面，但在非功能方面它如何工作，比如 Agency 处理更难的问题？

这最终就是这里的目标，对吧？我们说你前期做稍微大一点的投资，但我们相信我们带来的结构将帮助你提高结果的准确性。所以，虽然我们有一个团队的人基本上在努力让规范更好，但我飞回西雅图的工作是让整个 Curo 更快。一是执行时间和 UI 中的延迟，二是我们如何让 Token 更快地通过系统？我们如何更快地给你响应，这样你就不会在使用规范时在 Curo 上投入那么多成本？

是的。是的。我说的不是 Curo 工具本身，而是从规范生成的代码。

### (1:00:00 - End) Part 5

**(1:00:00 - 1:02:15)**

哦。哦，是的。好的。你指的是生成代码的非功能性需求吗？这取决于你具体想要做什么。你可以添加，我这里有一张幻灯片讲的是如何为你的用例调整流程和调整工件。同样，你可以很容易地添加类似"我希望在设计阶段考虑速度、运行时和锁争用等非功能性需求"这样的内容。是的，这些你肯定可以添加。所以你可以用 Rust 或 Java 生成代码。

是的，完全没问题。

**(1:02:15 - 1:04:30)**

根据你生成的语言，功能性会有所不同。

我的意思是它必须这样，没有其他方法来处理这个问题。我只是比较熟悉 node，所以我这里都用 node 做演示，但你可以在任何语言中使用它。技术上我们支持 Java、Python、JavaScript、TypeScript、Java 和 Rust。但实际上，没有理由这个系统不能适用于任何语言。我的意思是，它只是一个大语言模型。系统中没有任何特定于语言或框架的内容。

**(1:04:30 - 1:06:45)**

对于你们中的一些人，本周早些时候 Tessle 举办了一个会议，他们正在为知识库做一些规范。只要你有正确的基础文档，他们的观点是，无论你在构建什么都不重要，这一切都只是由你为系统构建的上下文来决定。

这也是引导的一个很好的要点。通过引导，你可以让代理按照你想要的方式开发代码。作为开发者就是要做权衡，而开箱即用的问题是它太礼貌了，因为它试图满足所有人的需求。特别是在延迟、成本和其他方面，只需在引导中告诉它你希望它优先考虑什么，这将影响生成的任何代码。

**(1:06:45 - 1:08:50)**

是的。

甚至它的设计方式也会基于这些。所以如果有什么特定于你的用例或你的行业或其他什么的，只需把它放在那个引导文件中。

是的，这完全正确。比如，我会让 Kira 为我生成提交。我个人关心的一件事是，我可以追踪我生成的提交与 Kira 生成的提交，也就是来自系统的提交。所以我的引导文档虽然很短，但包括了非常具体的要求，我对 Curo 的要求就是使用 UI，归属于 Kuro 代理的共同作者，这虽然微不足道，但我希望每次都这样做。

**(1:08:50 - 1:10:55)**

在这个例子中，它生成了一个由 Kirao 代理 D 共同撰写的提交。这是一个例子，说明你可以在那里添加任何你想要的东西，不仅仅是与 git 提交相关的，你可以做代码风格、代码覆盖率。每当你添加一个规范或添加新模块时，确保你用 90% 的覆盖率最低要求来标注它，因为这是我关心的事情。你可以在那里放任何你想要的东西。

好消息是我们构建的东西看起来是有效的。Cur 至少对自己很满意，看起来所有测试都通过了。但是，我们可以将其部署到后端，看看效果如何。

**(1:10:55 - 1:12:00)**

技术上我们刚好到时间了。如果有人还有其他问题，我会在这里待一会儿。但是，感谢大家的参与、聆听，以及进一步了解 Spectrum 和开发。

---

*生成时间: 2026-01-11 03:09:23*
*由 YouTube Monitor & Translator (Claude CLI) 生成*