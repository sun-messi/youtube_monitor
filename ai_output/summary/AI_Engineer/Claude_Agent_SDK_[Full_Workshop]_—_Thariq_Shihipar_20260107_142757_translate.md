# Claude Agent SDK [Full Workshop] — Thariq Shihipar, Anthropic

## 📹 视频信息

- **频道**: AI Engineer
- **发布日期**: 2026-01-05
- **时长**: 1:52:26
- **原始链接**: [https://www.youtube.com/watch?v=TqC1qOfiVcQ](https://www.youtube.com/watch?v=TqC1qOfiVcQ)

---

Looking at this transcript, I'll analyze this workshop on the Claude Agent SDK and create a comprehensive summary.

# Claude Agent SDK 工作坊

> 本文内容整理自 Anthropic 资深工程师塔里克·希希帕尔（Thariq Shihipar）在 AI Engineer 频道的技术工作坊。

## TL;DR

Claude Agent SDK 将 Claude Code 的强大功能打包成可重用框架，通过 Bash 工具和文件系统实现高度灵活的智能代理开发，使开发者能够快速构建从软件开发到数据分析等各种复杂任务的自主代理。

## 📑 章节导航表

| 时间戳 | 章节标题 | 一句话概括 |
|--------|----------|-----------|
| 00:00-10:00 | Agent SDK 介绍与背景 | 介绍 SDK 的起源、设计理念和在 Anthropic 内部的应用 |
| 10:00-20:00 | Bash 工具的核心地位 | 深入讲解为什么 Bash 是构建强大代理的关键工具 |
| 20:00-30:00 | 工作流 vs 代理设计 | 对比两种模式的适用场景和设计原则 |
| 30:00-40:00 | 技能系统与上下文管理 | 探讨技能（Skills）的使用和渐进式上下文披露 |
| 40:00-50:00 | 代理设计的三步循环 | 收集上下文、执行操作、验证工作的核心循环 |
| 50:00-60:00 | 电子表格代理案例分析 | 通过具体案例展示如何设计代理的搜索和验证机制 |
| 60:00-70:00 | 子代理与上下文管理策略 | 讨论如何使用子代理处理复杂任务和管理上下文窗口 |
| 70:00-90:00 | 实战演示：Pokemon 代理 | 现场演示如何从零开始构建一个 Pokemon 信息查询代理 |
| 90:00-110:00 | 部署与商业化讨论 | 探讨代理的部署架构、安全性和商业化策略 |

## 📊 核心论点

### 1. Bash 工具是构建强大代理的基石

- **核心内容**：Bash 不仅仅是执行命令的工具，而是第一个"代码模式"或"程序化工具调用"。它允许代理动态生成脚本、组合功能、使用现有软件（如 ffmpeg、LibreOffice），并将工具调用结果存储到文件系统。相比传统的固定工具集，Bash 提供了无限的灵活性和可组合性。
- **关键概念**：程序化工具调用、动态脚本生成、工具组合、文件系统集成、上下文工程
- **实际意义**：开发者无需为每个功能创建专门工具，而是让代理自主发现和组合现有能力，大幅降低开发复杂度并提高代理的通用性。

### 2. 代理开发的核心循环：收集-执行-验证

- **核心内容**：成功的代理设计遵循三步循环：1) 收集上下文（如 grep 查找文件、搜索邮件）；2) 执行操作（代码生成、Bash 命令、API 调用）；3) 验证工作（编译检查、规则验证、子代理审查）。验证步骤的强弱直接决定了代理的可靠性。
- **关键概念**：上下文收集、操作执行、工作验证、确定性规则、反馈循环
- **实际意义**：这个框架帮助开发者系统性地思考代理设计，特别是验证机制的设计决定了代理是否适合生产环境使用。

### 3. 文件系统作为上下文工程的核心

- **核心内容**：文件系统不仅是存储介质，更是代理的"记忆"和"工作空间"。通过将 API、技能、脚本组织在文件系统中，代理可以渐进式地发现和加载所需上下文，避免一次性加载过多信息污染上下文窗口。
- **关键概念**：渐进式上下文披露、文件系统作为 API、技能加载、动态脚本管理
- **实际意义**：这种设计让代理能够处理更复杂的任务，同时保持上下文使用的效率，为构建长时间运行的代理提供了基础。

### 4. 子代理是管理复杂度的关键机制

- **核心内容**：子代理允许将复杂任务分解为独立的子任务，每个子代理拥有独立的上下文窗口。主代理只需要子代理的最终结果，中间过程不会污染主上下文。这种模式特别适合并行搜索、数据聚合、独立验证等场景。
- **关键概念**：上下文隔离、任务分解、并行处理、结果聚合
- **实际意义**：使代理能够处理超出单个上下文窗口容量的复杂任务，同时提高执行效率和可靠性。

### 5. 从 Claude Code 原型到生产部署的路径

- **核心内容**：推荐的开发流程是：先在 Claude Code 中快速原型验证想法，观察代理行为并迭代提示词和 API 设计，然后提取成功的模式到 Agent SDK，最后部署到沙箱环境。整个过程强调"简单但不容易"——代码量少但需要优雅的设计。
- **关键概念**：快速原型、行为观察、模式提取、沙箱部署、简单性原则
- **实际意义**：这种方法让开发者能够快速验证想法，避免过早优化，同时确保最终方案的可靠性和可扩展性。

### 6. API 设计决定代理的能力上限

- **核心内容**：好的 API 设计应该让问题尽可能"分布内"（in-distribution）——利用模型已有的知识。例如，将电子表格查询转换为 SQL 接口，将复杂数据结构转换为 XML，让代理能够复用其对这些标准格式的理解。
- **关键概念**：分布内设计、接口转换、知识复用、语义对齐
- **实际意义**：通过巧妙的 API 设计，可以让代理在处理特定领域问题时表现得更加智能和可靠，而无需大量的定制训练。

### 7. 安全性需要多层防御策略

- **核心内容**：Agent SDK 采用"瑞士奶酪"防御模型：模型层的对齐训练、工具层的权限控制和解析器、运行时的沙箱隔离。特别是 Bash 工具的解析器能够理解命令意图，防止恶意操作。网络和文件系统的沙箱化是最后一道防线。
- **关键概念**：多层防御、权限控制、命令解析、沙箱隔离、网络限制
- **实际意义**：这种深度防御策略让企业能够放心地部署强大的代理，同时控制潜在的安全风险。

### 8. 技能系统实现领域专业知识的封装

- **核心内容**：技能（Skills）本质上是文件夹中的提示词和脚本集合，代表了特定领域的最佳实践。代理可以根据需要动态加载技能，获得处理特定任务的专业能力。这是一种优雅的知识管理和复用机制。
- **关键概念**：领域知识封装、动态加载、最佳实践复用、模块化设计
- **实际意义**：让非技术领域专家也能贡献自己的专业知识，构建一个可扩展的代理能力生态系统。

### 9. 商业化需要权衡定价模型

- **核心内容**：当前代理运行成本较高，建议针对高价值、复杂问题的客户群体。可以采用订阅制配合使用量限制，或纯使用量计费。关键是预先设计好商业模式，因为后期调整会影响用户信任。
- **关键概念**：高价值定位、订阅+使用量混合、成本控制、价值定价
- **实际意义**：帮助开发者在代理能力和商业可行性之间找到平衡点，构建可持续的业务模式。

### 10. 代理开发是艺术而非科学

- **核心内容**：构建优秀代理更像"骑马"——需要不断观察、调整和培养直觉。每个代理都有其独特性，需要通过反复阅读执行记录、尝试不同方法来找到最佳实践。模型是"生长"而非"设计"出来的，理解这一点对成功至关重要。
- **关键概念**：直觉培养、迭代优化、行为观察、实验精神、有机发展
- **实际意义**：提醒开发者保持开放和实验的心态，通过实践积累经验，而不是寻找一劳永逸的解决方案。

## 🏢 提及的公司/产品

| 公司名 | 讨论语境 | 重要性 |
|--------|----------|--------|
| Anthropic | Claude Agent SDK 的开发者，工作坊主办方 | ⭐⭐⭐ |
| Claude Code | Agent SDK 的基础，展示了代理能力的最佳实践 | ⭐⭐⭐ |
| Cloudflare | 提供代理部署的沙箱环境解决方案 | ⭐⭐ |
| Modal | 沙箱容器提供商，用于安全的代理执行环境 | ⭐⭐ |
| E2B | 代理执行环境提供商 | ⭐ |
| Poké API | 演示案例中使用的 Pokemon 数据 API | ⭐ |

## 💬 经典金句

> "Bash is all you need - it's the first programmatic tool calling."
> — Thariq Shihipar

> "Models are grown, not designed. We're understanding their capabilities organically."
> — Thariq Shihipar

> "Building an agent loop is more of an art than a science - it's like riding a horse."
> — Thariq Shihipar

> "Simple is not the same as easy - your agent should be simple, but achieving that simplicity requires elegant design."
> — Thariq Shihipar

## 👤 主要人物

### Thariq Shihipar

**身份**：Anthropic 资深工程师，Claude Agent SDK 主要开发者
**背景**：在 Anthropic 负责代理框架开发，深度参与 Claude Code 的构建。拥有丰富的前端和全栈开发经验，曾经历从 jQuery 到 React 的 Web 开发变革
**核心观点**：坚信 Bash 工具和文件系统是构建强大代理的关键，倡导通过实践和观察来理解代理行为，而非过度理论化。强调代理开发更像艺术创作，需要不断实验和迭代

## 📺 视频类型判断

**演讲独白**：技术教学、产品演示

---

## 📝 完整翻译

### (0:00 - 10:00) Agent SDK 介绍与背景
> 介绍 SDK 的起源、设计理念和在 Anthropic 内部的应用

好的，谢谢大家参加。我现在还在西海岸时间，所以感觉像是早上7点在做这个分享。

很高兴和大家聊聊 Claude Agent SDK。这是一个大概的议程，我们将讨论什么是 Claude Agent SDK？为什么要使用它？市面上有这么多其他的 agent 框架。什么是 agent？什么是 agent 框架？

我们将讨论如何使用 Agent SDK 或一般情况下如何设计一个 agent。然后我会做一些现场编码，或者说 Claude 会做一些现场编码来原型化一个 agent。我准备了一些启动代码。

我们有两个小时的时间，目标是超级协作式的，大家可以随时提问。这不会是一个超级预录的演示，我们会现场思考问题。我不会马上就有所有答案。我觉得这是构建 agent 循环的好方法，这真的更像是一门艺术或直觉。

在开始之前，我想了解一下，有多少人听说过 Cloud Agent SDK？好的，很棒。有多少人使用过或尝试过？很好，举手的人不少。

我先从 agents 的概述开始。我觉得这是人们之前见过的内容，但理解 AI 功能如何演进仍需要一些时间。

当 GPT-3 发布时，主要是关于单一 LLM 功能，比如"嘿，你能将这个分类并返回这些类别中的一个响应吗？"

然后我们有了更多类似工作流的东西，比如"嘿，你能给这封邮件打标签吗？"或者"这是我的代码库，通过 RAG 索引，你能给我下一个补全或下一个需要编辑的文件吗？"这就是我们称之的工作流，非常结构化。你会说"嘿，给定这些代码，给我返回代码"。

现在我们进入了 agents 时代。典型的 agent 例子就是 Claude Code。Claude Code 是一个工具，你不需要告诉它该做什么，我们也不会限制它能做什么。你只是用文本与它对话，它会采取非常广泛的各种行动。

所以 agents 会构建自己的上下文，决定自己的轨迹，工作时非常自主。随着未来的发展，agents 会变得越来越自主。

我认为我们正处于一个可以开始构建这些 agents 的转折点。它们并不完美，但绝对是开始的正确时机。

Claude Code，我相信你们很多人都试用过。我认为这是第一个真正的 agent，第一次我看到 AI 工作了10、20、30分钟。它是一个编码 agent，Claude Agent SDK 实际上就是基于 Claude Code 构建的。

我们这样做的原因是，当我们在 Anthropic 构建 agents 时，我们发现不断地在重复构建相同的部分。

给你一个感觉，首先当然是模型。然后在工具中，你有工具，这是第一个明显的步骤，让我们给这个工具添加一些工具。稍后，我们也会给出一个从头构建自己工具的例子，看看那是什么样子以及有多具挑战性。

但工具不仅仅是你自己的自定义工具，可能还有与文件系统交互的工具，比如 Claude Code。你在循环中运行工具，然后你有 prompts，核心 agent prompts，这样的提示词。

最后你有文件系统，或者不是最后但你有文件系统。文件系统是一种上下文工程的方式，我们稍后会更多地讨论。我认为我们通过 Claude Code 获得的一个关键洞察是更多地思考上下文，不仅仅是 prompt，还包括它可以使用的工具、文件和脚本。

### (10:00 - 20:00) Bash 工具的核心地位
> 深入讲解为什么 Bash 是构建强大代理的关键工具

然后还有我们最近推出的技能(skills)，如果你们也感兴趣的话，我们可以更多地讨论技能。

然后还有子代理、网络搜索、研究压缩、hooks、记忆，所有这些围绕工具的其他东西。最终这变成了相当多的内容。所以 Cloud Agent SDK 就是将所有这些东西打包供你使用，然后你有你的应用程序。

给你一个关于为什么 Cloud Agent SDK 的感觉，人们已经在 SDK 上构建了大量的软件 agents，软件可靠性、安全性、分类、bug 查找、站点和仪表板构建器。

如果你在使用这些，你绝对应该使用 SDK。我想还有办公 agents，如果你在做任何类型的办公工作，有大量的例子。还有一些法律、金融、医疗保健的。所以有大量的人在其基础上构建。

为什么选择 Cloud Agent SDK？为什么我们要这样做？为什么我们要基于 Claude Code 来构建？我们基本上意识到，一旦我们发布了 Claude Code，工程师开始使用它，但然后财务人员开始使用它，数据科学人员开始使用它，营销人员开始使用它。

我们意识到人们在使用 Claude Code 进行非编码任务，当我们构建非编码 agents 时，我们不断回到它。

我们会深入探讨为什么这样有效，为什么你可以将 Claude Code 用于非编码任务。剧透一下，这与 bash 工具有关。

这是我们看到的一种新兴模式，我们想要使用它，我们在其基础上构建了我们的 agents。这些是我们从部署 Claude Code 中学到的经验，我们将其融入其中。所以工具使用错误、压缩或类似的东西，这些需要大量规模才能发现的最佳实践，我们已经融入到 Cloud Agent SDK 中。

### (15:00 - 30:00) Part 2

你可以对网络进行沙箱隔离，这是一个很好的做法。如果你在沙箱容器上托管，比如 Cloudflare、Modal 或者 E2B、Daytona 等这些沙箱提供商，他们也在某种程度上做了安全处理。这样你就不是在个人电脑上托管，也不是在有生产环境密钥或类似东西的电脑上托管。所以这里有很多不同的安全层，我们可以更深入地讨论托管的问题。

好的，我要谈一下"bash 就是一切"这个概念。这是我的口头禅，你知道的。我会一直谈论这个，直到每个人都同意我的观点。我认为这是我们在 Anthropic 发现的东西，我觉得这是我来到这里后发现的。bash 是让 Claude Code 如此出色的原因。

我想你们可能已经看过代码模式或程序化工具使用，对吧？就像组合 MLP 的不同方式，Cloudflare 发布了一些相关博客，我们也发布了一些。我对代码模式或 bash 的理解是，它就像是第一个代码模式。bash 工具允许你将工具调用的结果存储到文件中，动态存储内存、生成脚本并调用它们，组合功能比如 tail 和 grep。它让你使用现有软件，比如 ffmpeg 或 LibreOffice。

bash 工具可以做很多有趣和强大的事情。再想想是什么让 Claude Code 如此出色。如果你在设计一个 agent 框架，也许你会有一个搜索工具、一个 lint 工具和一个执行工具，对吧？你会有 N 个工具。每次你想到一个新用例时，你就会想"我现在需要另一个工具"。但现在 Claude 只是使用 grep，以及你的包管理器。它可以运行 npm run test.ts 或 index.ts 之类的。它可以进行 lint 检查，可以找出你如何进行 lint，如果你没有 linter，它可以运行 npm run lint。它甚至可以说"要不要我为你安装 ESLint？"

### (20:00 - 30:00) 工作流 vs 代理设计
> 对比两种模式的适用场景和设计原则

这就像我说的第一个程序化工具调用、第一个代码模式。你可以非常通用地执行很多不同的操作。让我在非编码 agent 的语境下谈论这个问题。假设我们有一个邮件 agent，用户问"我这周在打车上花了多少钱？"一般来说，它有搜索收件箱的能力，可以运行查询比如"搜索 Uber 或 Lyft"。

如果没有 bash，它搜索 Uber 或 Lyft，得到大约一百封邮件，然后它就只能思考了。我觉得一个好的类比就是，想象如果有人拿着一叠纸来找你说"嘿，我这周在打车上花了多少钱？你能读一下我的邮件吗？"那会很难，对吧？你需要非常好的精确度和召回率才能做到。

但有了 bash，比如说有一个 Gmail 搜索脚本，它接收一个查询函数。然后你可以开始将查询函数保存到文件中或者用管道传递。你可以 grep 价格，然后将它们加起来。你还可以检查你的工作，对吧？比如你可以说"好，让我抓取所有价格，将它们存储在一个带行号的文件中，然后之后能够检查，这真的是一个价格吗？每个对应什么？"用 bash 工具可以做更多动态信息处理来检查你的工作。

这只是一个简单例子，但希望能向你展示 bash 可组合性的强大之处。我先暂停一下，对"bash 就是一切"或 bash 工具有什么问题吗？有什么我可以解释得更清楚的吗？

**观众：** 你有 YOLO 模式使用量的统计数据吗？

关于 YOLO 模式的统计数据，我们可能有，但在内部我们不使用，只是因为我们有更高的安全标准。我不确定具体数据，我可能可以查一下。关于 bash 还有其他问题吗？好的。

让我给你们一些更多的例子。假设你有一个邮件 API，你想要获取"告诉我这周谁给我发了邮件"。你有两个 API：收件箱 API 和联系人 API。这是你可以通过 bash 做到的方法。你也可以通过代码生成来做。这有点像足够的 bash，它就是代码生成。bash 本质上是一个代码生成工具。

假设你有一个视频会议 agent，你想说"在这个财报电话会议中找到所有发言人说'季度结果'的时刻"。你可以使用 ffmpeg 来切分这个视频，可以使用 jq 来分析之后的信息。所以有很多强大的方式来使用 bash。

我要谈一下工作流和 agent。你可以在 Agent SDK 上构建工作流和 agent。agent 就像 Claude Code。如果你正在构建某些东西，你希望用自然语言与之交谈并灵活地采取行动，那你就在构建一个 agent。你有一个与业务数据对话的 agent，你想获得洞察或仪表板或回答问题或编写代码，那就是一个 agent。

工作流有点像我们做很多 GitHub Actions，例如。你非常明确地定义输入和输出。比如"接受一个 PR，给我一个代码审查"。你可以为这两者使用 Agent SDK。在构建工作流时，你可以使用结构化输出，我们刚刚发布了这个功能。你可以搜索"Agent SDK 结构化输出"。但是，你可以同时做这两件事。我现在主要会谈论 agent，你从中学到的很多东西也适用于工作流。

### (30:00 - 45:00) Part 3

### (30:00 - 40:00) 技能系统与上下文管理
> 探讨技能（Skills）的使用和渐进式上下文披露

我认为我们正在朝着一个方向发展，就是越来越多的东西直接存储在文件系统中，这是一个很好的例子。它会随着时间推移存储长输出。我觉得通常提示 agent 这样做是一个很好的思路。甚至我现在总是这样做，每当我有工具调用时，我会将工具调用的结果保存到文件系统中，这样你就可以搜索它们，然后让工具调用返回结果的路径。这有助于它重新检查自己的工作。

那么你是否发现需要使用 skills 结构来帮助 Claude 更好地使用 bash，还是说开箱即用就可以？实际上这并不必要。

主持人：关于 skills 的问题，我们是否需要 skills 来更好地使用 bash？

让我解释一下 skills。Skills 基本上是一种让我们的 agent 承担更长、更复杂任务的方式，通过上下文加载内容。比如我们有一堆 DOCX skills，这些 DOCX skills 告诉它如何进行代码生成来生成这些文件。

Skills 基本上就是文件的集合。它们也是一个很好的例子，说明了我们如何非常依赖文件系统或 bash 工具。因为它们实际上就是文件夹，你的 agent 可以进入并读取。我们发现 skills 真正擅长的是那些需要大量专业知识的可重复指令。

比如我们最近发布了一个前端设计 skill，我非常喜欢。它本质上是一个非常详细和优秀的关于如何进行前端设计的 prompt。但它来自我们最好的 AI 前端工程师，他在上面投入了大量的思考和迭代。这是使用 skills 的一种方式。

观众：为什么使用那个前端 skill？

主持人：这是个好问题。感谢你发布它。我想了解一下，有多个 MP 文件，MP 也在那里，也在用户级别，然后有 skill 文件。是否有优先级顺序，某些内容应该放在 claude.md 中，而其他内容应该只在 skill.md 中？

关于 skill.md 与 claude.md 以及如何思考这个问题的问题。我要说的是，所有这些概念都很新。Claude Code 大约在八九个月前发布，而 skills 在两周前才发布。我不会假装知道所有的最佳实践。

我认为 skills 是渐进式上下文披露的一种形式，这是我们经常讨论的模式。就像使用 bash 而不是纯粹的常规工具调用一样，这是 agent 的一种方式，比如"好的，我需要做这个，让我找出如何做这个，然后让我读入这个 skill"。所以你要求它制作一个 docx 文件，然后它进入目录，读取如何做，编写一些脚本并继续进行。

我认为在如何定义 skill 以及如何拆分方面，仍然需要建立一些直觉。但在这方面还有很多最佳实践需要学习。

观众：昨天我们讨论了 skills 随时间的未来发展。你是否认为这些最终会成为模型的一部分，而 skills 只是现在弥合差距的一种方式？

关于 skills 是否最终会成为模型一部分的问题。我错过了 Barry 和 M 昨天的演讲，但大致的想法是模型会越来越好地执行各种任务，而 skills 是给它分布外任务的最佳方式。

但我要广泛地说，特别是如果你不在实验室工作，真的很难确切知道模型的发展方向。我的一般经验法则是，我试着每6个月重新思考或重写我的 agent 代码，因为事情可能已经发生了足够大的变化，我可能已经烤入了一些假设。

我认为我们的 Agent SDK 是为了尽可能地与能力一起发展而构建的。bash 工具会变得越来越好。我们在 Claude Code 之上构建它，所以随着 Claude Code 的发展，你会立即获得这些好处。但同时，与一年前相比，现在的 AI 工程方面完全不同。

我认为一个一般的最佳实践是，我们可以编写代码快10倍，我们也应该丢弃代码快10倍。我认为应该考虑的不是对未来在哪里下注，而是我们今天能做什么真正有效的事情。让我们今天获得市场份额，不要害怕以后丢弃代码。

如果你是一家初创公司，这可以说是你相对于竞争对手的最大优势。较大的公司有六个月的孵化周期，所以他们总是停留在过去的 agent 能力上。你的优势是你可以说"嘿，agent 能力现在就在这里，让我现在就构建使用它的东西"。

关于 skills 和 bash 还有其他问题吗？看起来有很多关于 skills 的问题。

观众：为什么使用 skill 而不是 API？它们看起来非常相似，那个 Python 程序可能是一个包，对吧？

关于为什么使用 skill 而不是 API 的问题。这些都是基本上向 agent 进行渐进披露的形式，让它弄清楚需要做什么。这完全取决于使用案例。我认为没有一般规则。我认为应该阅读记录并看看你的 agent 想要什么。如果你的 agent 总是将 API 更多地视为 API.ts 文件或 API.py 文件，那就这样做。

### (40:00 - 50:00) 代理设计的三步循环
> 收集上下文、执行操作、验证工作的核心循环

我认为 skills 是思考文件系统作为存储上下文方式的一种介绍，它们是一个很好的抽象。但有很多方法可以使用这个系统。关于 skills，你需要 bash 工具，你需要虚拟文件系统等等。所以 Agent SDK 基本上是现在真正充分使用 skills 的唯一方式。

观众：我们能期待 skills 的市场吗？

关于是否能期待 skills 市场的问题。Claude Code 有一个插件市场，你也可以与 Agent SDK 一起使用。我们正在随着时间推移发展它，这更像是一个 v0。就市场而言，我不确定人们是否会确切地为此收费，我认为这更像是一个发现系统。但现在就存在，你可以在 Claude Code 中做 `/plugins`，你可以找到一些。

观众：关于何时使用 SDK 来解决问题，你目前的想法是什么？

关于何时使用 SDK 来解决问题的问题。如果我在构建 agent，基本上我的总体信念是，对于任何 agent，bash 工具给你如此多的力量和灵活性，使用文件系统给你如此多的力量和灵活性，你总是可以从中榨取性能增益。

在这次演讲的原型制作部分，我们将看一个只使用工具的例子和一个使用 bash 和文件系统的例子，并比较这两者。这就是我所说的"bashful to build"的意思。我就是从 Agent SDK 开始，我认为 Anthropic 的很多人也开始这样做。

当然，我确实想说有很多时候 Agent SDK 有点烦人，因为你有这个网络沙盒容器，你会想"我讨厌这个，我不想这样做，我想在本地浏览器上运行"。我完全理解这一点，我认为这确实存在性能权衡。

我的思考方式有点像 React 与 jQuery。当我刚开始时，我非常喜欢 web 开发，我使用 jQuery 和 Backbone，然后 React 出来了，它是由 Facebook 制作的，他们说"你必须使用 JSX，我们刚刚编造了这个，现在有一个打包器"，我想"这太烦人了"。但它通常使模型或让 web 应用程序更强大。我认为 Agent SDKs 对我来说就像是 agent 框架的 React，因为我们在它之上构建我们自己的东西。

更多的 skills 问题。

观众：关于 bash，如果你有自定义内部 bash 工具，如何让 agent 发现它，或者那些必须成为工具？

关于如果你有自定义 agent bash 工具，如何让 agent 发现它的问题。你是指 bash 脚本？

你只需将它放在文件系统中并告诉它"嘿，这里有一个脚本，你可以调用它"。我通常在 Claude Agent SDK 的上下文中思考，它有文件系统，bash 工具是绑定在一起的。我有时看到的一种反模式是人们说"我们要在这个虚拟化的地方托管 bash 工具，它不会与 agent 循环的其他部分交互"，这使得它变得困难，因为如果你有一个保存文件的工具结果，那么你的 bash 工具就不能读取它，除非都在一个容器中。

我只是在系统提示中说"嘿，你可以访问这个"。我会设计我所有的 CLI 脚本都有 `--help` 或类似的东西，这样模型就可以调用它，然后它可以渐进地披露脚本内部的每个子命令。

### (45:00 - 1:00:00) Part 4

你只能接收这个输入，需要给出这个输出，必须对 agent 屏蔽数据库的其他一切信息，对吧？显然这样就限制了 agent 能做的事，它无法写出非常动态的查询。

如果你要写完整的 SQL 查询，我绝对会使用 bash 或者代码生成，因为当模型写 SQL 查询时，它可能会犯错，而它修复错误的方式是通过代码检查或者运行文件，查看输出，看是否有错误，然后反复迭代。

所以一般来说，如果我今天在构建 agent，我会给它尽可能多的数据库访问权限，然后设置防护措施。比如我可能会在不同方面限制它的写入权限。但我大概会这样做：给它写入权限，制定具体规则，然后如果它试图做不被允许的事情就给予反馈。你明白我的意思吗？

我知道这是个很难的问题，但我认为这就是我们需要解决的一类问题。我们构建了 bash 工具解析器，这是个非常麻烦的问题，但我们需要解决它才能让 agent 更好地工作。数据库也是同样的道理 - 是的，理解查询在做什么很困难，但如果你能解决这个问题，你就能让你的 agent 随着时间推移工作得更通用。

所以我认为要尽可能灵活地思考这个问题，保持工具是非常原子化的操作，你需要围绕它们有很多保证。

主持人：关于同样的问题，你如何确保基于角色的访问控制得到妥善处理？

这个问题是如何确保基于角色的访问控制得到妥善处理。通常这是在你配置 API 密钥或后端服务时处理的。我想我会做的是创建临时 API 密钥，有时人们会创建代理来插入 API 密钥，如果你担心数据外泄的话。

但是的，我会为你的 agent 创建在某些方面有范围限制的 API 密钥，这样在后端你就可以检查它试图做什么，如果它是个 agent，你可以给它不同的反馈。

主持人：好的。我还有一个问题。你能告诉我们更多关于内部记忆工具的信息吗？

我并不是想保密什么。我不知道确切情况 - 我没有读过代码，但我认为它通常在文件系统上工作。

主持人：你把它暴露给 SDK 了吗，还是已经可用了？

我想说我们收到过很多这样的问题。在 Claude Agent SDK 中我就直接使用文件系统。我会创建一个 memories 文件夹之类的，告诉它在那里写入记忆。我不知道记忆工具的确切实现，但它确实以那种方式使用文件系统。

### (50:00 - 1:00:00) 电子表格代理案例分析
> 通过具体案例展示如何设计代理的搜索和验证机制

主持人：好的，关于这个的最后一个问题。你如何管理代码的可重用性？假设同一个 agent 被部署给数百个用户，每次都在生成相同的代码并执行。我们如何利用可重用性？

这是个很好的问题。假设你有两个 agent 与两个不同的人交互，问题是你如何考虑 agent 之间的可重用性，或者 agent 如何通信，对吧？

我认为这是有待发现的事情。我觉得在系统设计方面有很多最佳实践需要探索，因为传统上 web 应用是为百万用户提供一个应用，而对于 agent - 比如 Claude Code - 我们提供一对一的容器，当你在 web 上使用 Claude Code 时，那是你的容器，所以容器之间没有太多通信，这是个非常不同的范式。

我不会说我确切知道最佳的系统设计方法，我觉得有很多最佳实践需要探索，比如这些 agent 如何重用工作，我们如何给它们通用脚本来结合它们已完成的工作，如何让它们共享等等。

一般来说，我认为这有点跑题了，但关于 agent 通信框架，我想说的是我们可能不需要重新发明一个新的通信系统。agent 很擅长使用我们现有的东西，比如 HTTP 请求、hash 工具、API 密钥、命名管道等等。所以 agent 们可能只是通过 HTTP 服务器相互发送 HTTP 请求。

这里有很多有趣的工作。我见过有人为他们的 agent 创建虚拟论坛来通信，它们发帖主题并回复之类的，挺酷的。我觉得在这方面有很多东西需要探索和发现。

好的，我们再继续一点。时间怎么样？好的，我想还剩一个小时。

很好。那么，agent 设计的一个例子。这不是原型制作环节，但我觉得这会是一个很好的过渡。假设我们在制作一个电子表格 agent。搜索电子表格的最佳方式是什么？在电子表格中执行代码或采取行动的最佳方式是什么？链接电子表格的最佳方式是什么？这些都是非常有趣的事情。

我要用 Figma 演示，我们可以过一遍。如果有人能拿杯水就太好了，我真的需要水。

好的，谢谢。那么，我们来讨论一下。或者你们为什么不花几分钟时间自己思考这个问题？你有一个电子表格 agent，你希望它能够搜索，能够收集上下文、采取行动、验证其工作。你会如何考虑这个问题？就花点时间思考一下，做点笔记什么的。

好的，大家都有一点时间思考了吗？有人想要更多时间还是直接开始讨论？

好的，agent 搜索电子表格的最佳方式是什么？意识到我现在得单手打字。我应该搞清楚这个，因为我稍后还要打字。

好的，搜索电子表格。有什么想法，你如何搜索电子表格？你会怎么做？

观众：CSV。

好的，你有一个 CSV。现在你的 agent 想要搜索 CSV，它会怎么做？

观众：用 grep。

好的，grep 看起来像什么？

观众：需要查看所有的标题。

查看标题，好的。

观众：所有工作表的标题。

好的，很好。假设我在寻找 2024 年的收入。

现在我有了标题，我打开一个电子表格。假设收入在这里有一个收入列，然后还有...

好，假设是这样的。我如何获得 2026 年的收入？这是个表格问题，收入在这里，2026 也在这里，所以这是个多维步骤。我们可以查看标题，如果你只是拉取这个，你会得到 100、200、300。所以我们需要更多信息。还有其他想法吗？

观众：有个 bash 工具，我想是 AWK。

哦，好的。那 AWK 会做什么？

观众：嗯，取决于你要寻找什么。

是的，这就是问题，对吧？用户要寻找什么？他们可能在寻找像这样的东西，比如 2026 年的收入。

观众：也许使用 API，使用 Google 工具把所有数字加起来，或者 VLOOKUP 之类的。

是的，想法是使用 API，比如使用 Google API 来查找。这很好，但假设我们在本地工作，需要设计这些 API。

观众：SQLite 或者直接处理 CSV。

哦，有趣。好的，我不知道那个，太好了。所以你使用 SQLite 查询 CSV。这是一种很棒的创造性思考 API 接口的方式。如果你能把某个东西转换成 agent 非常熟悉的接口，那就太好了。所以如果你有数据源，如果你能把它转换成 SQL 查询，那么你的 agent 真的知道如何搜索 SQL。

思考这种转换步骤真的很有趣，这是设计代理搜索接口的绝佳方式。

观众：我们在讨论工具时，你也可以使用 TSV 来做其中一些事情。Claude 是否足够智能来开始为合适的工作排列合适的工具？因为这就是我们在这里讨论的 - 合适工作的合适工具。

Claude 是否足够智能来为合适的工作排列合适的工具？如果你提示它的话，是的。我觉得这是其中一件事情，我不知道，让我们找出答案，让我们阅读记录。如果不是，你如何帮助它？

我认为所有这些事情都像是直觉，就像骑马一样。不是说我骑过马，但我知道就像我想象的那样像跑步。

[笑声]

你在给马这些信号，让它平静下来，你试图理解如何让它跑得更快？你明白我的意思吗？这是个非常有机的事情。我觉得我们喜欢说模型是成长的而不是设计的，所以我们在理解它们的能力。

### (1:00:00 - 1:15:00) Part 5

### (1:00:00 - 1:10:00) 子代理与上下文管理策略
> 讨论如何使用子代理处理复杂任务和管理上下文窗口

你可以进行 SQL 查询，对吧？Agent 对 SQL 查询非常了解。你也可以处理 XML，对吧？抱歉，字体太小了。你们可能知道 XLS 文件在后端其实就是 XML，XML 是非常结构化的，你可以进行 XML 搜索查询，有不同的库可以做到这一点。

这就是搜索和收集上下文的一个例子，我希望这能说明收集上下文真的非常具有创造性。有很多种迭代方式，如果你只尝试了一种迭代，那可能是不够的。尽可能多地思考不同的方式，尝试 SQL、尝试其他方法、尝试 GPT 等等，针对不同的情况进行多种测试，看看 Agent 喜欢什么，不喜欢什么。每种情况都会不同。

主持人：当你说 Agent 时，你指的是模型吗？因为我们在这里构建一个 Agent。

是的，你依赖的是现有的如何处理 XML 的知识，是谁在做这件事？是模型。

是的，因为问题是知识从哪里来？是模型吗？Agent 是什么意思？一般来说，我认为你寻找的是有一个问题，你想让它尽可能符合 Agent 的分布，对吧？Agent 对很多不同的事情都了解很多。例如，它对金融了解很多，所以如果你要求它制作 DCF 模型，它知道什么是 DCF。

如果你想给它更多信息，你可以创建一个技能。它知道什么是 DCF，知道什么是 SQL。它能将这些东西结合起来吗？理想情况下，你的问题在某种程度上会超出分布范围，比如有一些不在互联网上的信息，或者对你来说有些独特的东西，你想尝试将其调整为尽可能符合分布。这确实非常有创造性，不像科学，更像是一门艺术。

好的，我们已经尝试过收集上下文，然后采取行动。我们在这里可能可以做很多之前做过的相同事情，比如插入二维数组。如果我们有 SQL 接口，我们可以进行 SQL 查询，可以编辑 XML。这些通常非常相似，采取行动和收集上下文，你可能希望有一个相似的 API 来回传递。最后一件事是验证工作，你如何思考这个问题？检查空指针是其中一种方法。对于验证还有其他想法吗？

主持人：抱歉，我有点困惑，如果你说当使用其他 SDK 构建 Agent 时，我不需要告诉它应该如何收集上下文。

当然。

我只是给它上下文，用简单的英语解释这是什么意思以及它应该做什么。

是的。

我通常会做的是，你告诉我是否错误，我实际上最终会创建一个单独的 Agent 进行 QA。

很有趣。

为了验证，因为我不信任 Agent 来验证自己。但我只是对我需要在那个例子中向 Agent 提供的详细程度有点困惑。

好的。所以问题是关于向 Agent 提供上下文与让它收集自己的上下文。你提到有时使用 Q&A Agent。我能问一下你在什么领域构建你的 Agent 吗？

网络安全。

好的。我认为 Claude Agent SDK 对网络安全很棒，我通常会推动人们尽可能让 Agent 收集上下文，让它尽可能找到自己的工作。你试图给它找到自己工作的工具。

我这样思考：假设有人把你锁在房间里，他们在给你任务，这就是你的工作，就像 Mr. Beast 的场景一样。如果你在这个房间里待 6 个月就能得到 50 万美元。有人给你发消息，你想要什么工具来完成它？你只想要一堆论文，还是想要计算器或电脑？我可能想要电脑，想要 Google，想要所有这些东西。

### (1:10:00 - 1:30:00) 实战演示：Pokemon 代理
> 现场演示如何从零开始构建一个 Pokemon 信息查询代理

我不想要那个人给我发一堆论文说"嘿，这可能是你需要的所有信息。"我宁愿说"嘿，给我一台电脑，给我问题，让我搜索并解决它。"这就是我对 Agent 的思考方式，它们需要工具，它们被困在房间里。

所以我需要给它们工具。如果你能回到幻灯片，你有的那个图表。

这个图表，或者...

是的，基本上收集上下文就是这些我提供给它的工具。

是的，完全正确。我给它一个代码生成的 API，给它一个 SQL 工具，给它 bash，这些都是例子。

主持人：你有的所有 Agent，它们共享相同的上下文窗口吗？

很有趣。Agent 是否共享上下文窗口？我认为这是关于如何管理上下文的一个有趣问题。我还没有谈论太多，但子 Agent 是管理上下文的一个非常重要的方式。我们在 Claude Code 内部越来越多地使用子 Agent，我会非常普遍地考虑使用子 Agent。

对于电子表格 Agent，我们可能有一个搜索子 Agent。子 Agent 非常适合当你需要做大量工作并向主 Agent 返回答案时。对于搜索，假设问题是"我如何找到 2026 年的收入？"也许你需要做一堆结果，也许你需要搜索互联网，也许你需要搜索电子表格，诸如此类。有很多东西不需要进入主 Agent 的上下文，主 Agent 只需要看到最终结果。这是一个很好的子 Agent 任务。

主持人：对于验证，你可以想象通过技能或子 Agent 来做这件事。你甚至可能想要有一个对抗性的，比如安全例子就是一个很好的例子。想要真正深入研究它，与已经完成的工作没有任何同情关系。这是一个光谱，但你会在这里使用子 Agent，还是使用技能？你如何思考这个问题？

是的，绝对。关于是否使用子 Agent 进行验证的问题。是的，我认为这是一个模式。理想情况下，最好的验证形式是基于规则的，比如是否有空指针？这是简单的验证。如果它不能 lint 或编译，尽可能多地尝试插入规则，再次要有创造性。

### (1:15:00 - 1:30:00) Part 6

是的，关于上下文污染管理的问题。你是否有一个经验法则，比如在开始出现收益递减或效果下降之前，应该使用多少上下文窗口？

这实际上是一个非常有趣的问题。我发现当我与使用 Claude Code 的人交谈时，他们会说："我已经是第五次压缩了。"我会想："什么？"我自己几乎从来没有做过压缩。我必须强迫自己进行压缩来测试用户体验，因为我在使用 Claude Code 时倾向于非常频繁地清理上下文窗口。

至少在代码中，状态存在于代码库的文件中。假设我做了一些更改，Claude Code 可以查看我的 git diff 然后说："哦，这些是你做的更改"，它不需要知道我与它的整个聊天历史来继续新任务。所以在 Claude Code 中，我经常清理上下文，然后说："嘿，看看我未提交的 git 更改。我正在处理这个，你能帮我以这种方式扩展它吗？"

当你构建自己的 Agent 时，比如电子表格 Agent，情况会变得更复杂，因为你的用户技术水平较低，他们不知道什么是上下文窗口。这是一个难题。我认为这里有一些用户体验设计的问题，比如你能否重置对话状态？每次用户提出新问题时，你能否进行自己的压缩并总结上下文？在电子表格中，大部分状态都在电子表格本身，所以它可能不需要知道整个上下文。

你能否在过程中存储用户偏好以记住这些东西？有很多不同的角度和方法来处理这个问题。但是你试图最小化上下文使用，你可能不需要一百万的上下文，你只需要良好的上下文管理和用户体验设计。

观众：我想问关于子 Agent 的问题，子 Agent 是为了保护核心 Agent 的行为而创建的。在电子表格的情况下，我们能否使用多个子 Agent 并创建一个流程，当电子表格超大时将其分块，然后 Agent 可以并行处理每个部分？

是的，绝对可以。我喜欢 Claude Code 的一个原因是我们提供了使用子 Agent 的最佳体验，特别是带有 bash 的子 Agent，这非常好。当你同时运行并行子 Agent 时，bash 变得非常复杂，有很多竞态条件等问题，我们已经解决了很多这样的工作。这是我喜欢 Claude Code 的原因之一，你可以说："嘿，启动三个子 Agent 来完成这个任务"，它就会这样做。

在 Agent SDK 中，子 Agent 是一个很棒的原语，我没有见过有人做得这么好。对于电子表格，你可能会同时有多个读取子 Agent。主 Agent 可能会说："这个 Agent 能读取并总结表格一吗？这个 Agent 能读取并总结表格二吗？这个 Agent 能总结表格三吗？"然后它们返回结果，然后 Agent 可能再次启动更多的子 Agent。

我想说的是，我们已经谈论了很多不同的创造性方法。这是你应该思考问题的层面。在我看来，你不应该真正思考如何启动进程来创建子 Agent，或者什么是压缩之类的系统工程问题。我们在框架中为你处理所有这些，这样你就可以思考需要启动什么子 Agent，如何创建智能搜索界面，如何验证它的工作。这些是你必须解决的真正核心和困难的问题。

观众：关于验证任务，我们究竟需要在哪里放置验证？比如在生成 SQL 查询后验证生成的查询是否正确，这是一条路径。第二条路径是生成查询后直接执行，一旦获得输出再进行验证。Agent 如何动态选择正确的路径？

关于在哪里进行验证的问题。是只在最后验证还是在中间验证？我会说在任何可能的地方都进行验证，持续验证。我说过我们在 Claude Code 的读取步骤中进行一些验证，这是一个很好的例子。

你可以在最后验证，绝对应该在最后验证，但在其他任何有规则或启发式方法的地方也可以验证。例如，你的规则之一是搜索的列总数应该少于10,000或1,000，这是一个很好的方法。类似地，也许你不应该插入巨大的行值，给模型反馈说："嘿，把这个分块"，抛出错误并给出反馈。模型的好处是它会听取反馈，它会读取错误输出然后继续。所以验证绝对可以在任何地方发生，并且应该在任何地方发生，尽可能多地使用它。

观众：我们如何形成步骤？我是说，我们如何告诉 Agent 先搜索，然后这一步，然后那一步？循环实际上如何从起点到终点？

你只需要告诉它。在系统提示中。是的，就像 Claude Code 一样，我们给它 bash 工具并说："嘿，收集上下文，读取你的文件，做一些事情，运行你的 linting。"对于 Agent，你不需要强制执行这个，你不需要告诉它必须这样做，因为有时可能不必要。

比如有人对你的电子表格提出只读问题，你不需要验证没有编译错误，因为你没有进行任何写操作。让 Agent 保持智能，就像你在工作时想要的那种自由一样。

好的，我确实想尝试做一些原型设计。我们已经进行了很多问答。让我们说你想构建一个 Agent，你听完这个演讲后想法很多。我总的想法是构建 Agent 应该是简单的。你的 Agent 最终应该是简单的，但简单不等同于容易。

开始应该非常简单，就是去 Claude Code，给 Claude Code 一些脚本和库以及自定义 Claude 身份，然后要求它去做。应该很容易说："嘿，这是我的 API，这是 API 密钥，你能搜索我的客户支持工单并按优先级组织它们吗？"然后看看 Claude Code 做了什么并在此基础上迭代。这是跳过困难的特定领域问题的好方法，比如如何组织你的数据、你的智能搜索、如何为数据库创建护栏，这些都是你可以立即开始用 Claude Code 解决的问题。

### (1:30:00 - 1:45:00) Part 7


---

*生成时间: 2026-01-07 14:25:57*
*由 YouTube Monitor & Translator (Claude CLI) 生成*