# Automating Large Scale Refactors with Parallel Agents - Robert Brennan, AllHands

## 📹 视频信息

- **频道**: AI Engineer
- **发布日期**: 2026-01-08
- **时长**: 1:16:22
- **原始链接**: [https://www.youtube.com/watch?v=rcsliSIy_YU](https://www.youtube.com/watch?v=rcsliSIy_YU)

---

## Video Summary & Analysis

本文内容整理自 OpenHands 联合创始人兼 CEO 罗伯特·布伦南（Robert Brennan）和工程师卡尔文（Calvin）在 AI Engineer 频道的技术演讲。

### TL;DR（一句话核心洞察）

通过并行 Agent 编排技术，OpenHands 将传统需要数月完成的大规模代码重构任务（如 CVE 修复、框架迁移）压缩到数周甚至数天，实现了 30 倍效率提升，关键在于将大任务智能分解为可并行执行的小任务，并保持人机协作的验证环节。

### 📑 章节导航表

| 时间戳 | 章节标题 | 一句话概括 |
|--------|----------|-----------|
| 00:00-05:00 | 开场与 AI 编程演进历史 | 从代码片段生成到自主编程 Agent 的技术演进路径 |
| 05:00-10:00 | Agent 编排的应用场景 | CVE 修复、代码现代化、技术债务清理等大规模重构任务 |
| 10:00-18:00 | 编排的技术挑战与解决方案 | 上下文限制、任务分解、人机协作的最佳实践 |
| 18:00-27:00 | Calvin 演示：代码异味清理案例 | 使用依赖图可视化和批处理策略消除 60,000 行代码的技术债务 |
| 27:00-34:00 | 任务分解与上下文共享策略 | 并行 Agent 如何高效协作和知识传递 |
| 34:00-45:00 | 实战演练：环境搭建 | 配置 GitHub、OpenHands SDK 和 Agent 服务器 |
| 45:00-60:00 | CVE 扫描 Agent 实现 | 创建自动扫描仓库漏洞的智能 Agent |
| 60:00-76:00 | 并行修复 Agent 部署 | 为每个漏洞创建独立 Agent 并行修复 |

### 📊 核心论点

#### 1. Agent 编程的四阶段演进模型

- **核心内容**：从 2022 年的"上下文无关代码片段"（如 ChatGPT 生成算法）到 2024 年的"并行 Agent 编排"，软件开发经历了四个关键阶段：(1)上下文无关代码生成 (2)上下文感知代码补全（GitHub Copilot）(3)自主编程 Agent（可运行、调试、迭代）(4)并行 Agent 协作。这种演进让开发者角色从"编写代码"转变为"管理 AI 团队"，类似于从 IC 转为 Manager 的职业转变。
- **关键概念**：上下文感知、自主执行、Agent 编排、开发者角色转型、生产力阶跃
- **实际意义**：即使 LLM 技术今天停止进步，未来 2-3 年软件工程仍将发生巨大变化，因为我们还在学习如何操作化现有技术。早期采用者已获得 30 倍生产力提升。

#### 2. 大规模重构的可并行化原则

- **核心内容**：传统单 Agent 在处理大型任务时面临四大限制：上下文窗口有限、"懒惰"问题（只完成部分任务）、领域知识不足、错误累积效应。解决方案是将大任务分解为"可一次性完成、可并行执行、易于验证、依赖关系清晰"的小任务。OpenHands 客户在 CVE 修复场景中，通过并行运行数百个 Agent，将漏洞修复时间缩短 30 倍。
- **关键概念**：任务原子化、并行度最大化、验证自动化、依赖管理、错误隔离
- **实际意义**：企业可以清理积压多年的技术债务；安全团队可以快速响应新漏洞；大型迁移项目（如 Java 8 到 17）从年级别缩短到周级别。

#### 3. 依赖图驱动的批处理策略

- **核心内容**：Calvin 展示了如何将 60,000 行代码的重构任务通过依赖图可视化，按目录结构分组为语义相关的批次。每个批次包含 2-10 个文件，由独立 Agent 处理。系统自动识别无依赖的"叶节点"批次优先处理，确保修改不会破坏下游代码。每个批次生成独立的 PR，包含详细的修改说明和代码异味清理报告。
- **关键概念**：依赖图分析、批次化策略、叶节点优先、语义分组、PR 粒度控制
- **实际意义**：将不可管理的大型重构转化为可审查、可回滚、可并行的小型更改；提高代码审查质量；降低引入 bug 的风险。

#### 4. 90% 自动化的人机协作模型

- **核心内容**：Agent 编排的目标不是 100% 自动化，而是 90% 自动化配合 10% 人工审核。人类在三个关键节点介入：(1)任务分解和编排设计 (2)中间结果审查和反馈 (3)最终 PR 审核和合并。这种模式下，人类提供高层次决策和质量把关，Agent 执行重复性工作。一个工程师可以管理 3-5 个并发 Agent（熟练后可扩展到数百个）。
- **关键概念**：人类决策点、中间审查、质量把关、认知负载管理、渐进式扩展
- **实际意义**：保证代码质量的同时获得数量级生产力提升；避免 AI 生成代码的质量风险；让工程师专注于架构决策而非机械劳动。

#### 5. 上下文共享的四种模式

- **核心内容**：并行 Agent 之间的知识共享有四种策略：(1)共享所有内容（低效，易爆上下文）(2)人工传递关键信息（不可扩展）(3)通过共享文件（如 agent.md）异步更新 (4)Agent 间直接通信（实验性）。实践中，混合使用策略 2 和 3 最有效：人类发现的关键信息写入共享文件，Agent 可读取但需人工审核才能修改。
- **关键概念**：选择性共享、异步更新、人工审核、信息过滤、避免信息过载
- **实际意义**：防止 Agent 重复遇到相同问题；加速整体任务完成；避免无关信息污染；保持系统可控性。

#### 6. 任务分解的三种架构模式

- **核心内容**：大型重构有三种分解模式：(1)逐件处理（适合独立性强的任务如添加类型注解）(2)依赖树遍历（从工具类开始逐层向上）(3)脚手架模式（创建临时兼容层，如同时支持新旧框架）。OpenHands 在迁移 Redux 到 Zustand 时采用脚手架模式，允许组件逐个迁移的同时保持应用可运行。
- **关键概念**：任务独立性、依赖顺序、渐进式迁移、临时兼容层、可验证性
- **实际意义**：根据任务特性选择合适模式可大幅提高成功率；脚手架模式特别适合高风险的框架迁移；依赖树模式确保改动的正确传播。

#### 7. 从本地 Agent 到云端编排的采用路径

- **核心内容**：市场采用呈现清晰的成熟度曲线：普通开发者使用 IDE 内的 AI 辅助（GitHub Copilot）→ 早期采用者使用本地 Agent（Claude Code）→ 1% 先锋用户使用云端 Agent → 顶尖团队实现大规模编排。云端 Agent 的优势：安全隔离、无限并行、自主运行 24/7。挑战在于开发者心理："把工作交给 AI"的感觉类似于"从写代码转为管理团队"。
- **关键概念**：采用成熟度、心理障碍、安全隔离、扩展性、自主度
- **实际意义**：企业应根据团队成熟度制定 AI 采用策略；云端 Agent 是规模化的必经之路；需要培训和文化转变来克服采用障碍。

#### 8. CVE 自动修复的完整工作流

- **核心内容**：演示的 CVE 修复流程包括：(1)主 Agent 扫描仓库识别漏洞（自动选择 npm audit/trivy 等工具）(2)为每个漏洞创建独立修复 Agent (3)每个 Agent 研究漏洞、更新依赖、修复 API 破坏性变更 (4)自动生成 PR 供人工审核。关键创新：Agent 可自主选择扫描工具、并行处理多个漏洞、处理级联依赖更新。
- **关键概念**：工具自动选择、并行修复、API 兼容性处理、PR 自动化、选择性合并
- **实际意义**：将安全响应时间从天缩短到小时；处理复杂的依赖链更新；即使部分漏洞无法自动修复，其他的仍可完成。

#### 9. Agent SDK 的关键抽象

- **核心内容**：OpenHands SDK 提供了四个核心抽象：(1)LLM 对象（支持多种模型）(2)Agent 对象（配置工具和行为）(3)Workspace（Docker 容器化的安全环境）(4)Conversation（管理上下文和任务历史）。通过组合这些抽象，开发者可以构建复杂的多 Agent 系统，如 refactor-tools 中展示的批处理管理器。
- **关键概念**：抽象层次、容器化工作区、会话管理、工具配置、安全沙箱
- **实际意义**：降低构建 Agent 系统的复杂度；提供生产级的安全和隔离；支持从简单脚本到复杂编排的平滑过渡。

#### 10. 开源驱动的 AI 开发工具演进

- **核心内容**：OpenHands（原 OpenDevin）的诞生源于对"AI 改变软件开发不应在黑箱中发生"的信念。作为 MIT 协议的开源项目，它让开发者社区能够参与定义 AI 辅助开发的未来。这种开源方式带来了快速创新：从模仿 Devin 的单 Agent，到如今支持大规模并行编排，仅用时 18 个月。
- **关键概念**：开源协作、社区驱动、透明度、快速迭代、民主化 AI 工具
- **实际意义**：避免 AI 开发工具被少数公司垄断；加速最佳实践的传播；让中小团队也能使用企业级 AI 工具。

### 🏢 提及的公司/产品

| 公司名 | 讨论语境 | 重要性 |
|--------|----------|--------|
| OpenHands | 开源 AI 编程助手平台，本次演讲的核心产品 | ⭐⭐⭐ |
| Devin | 首个自主编程 AI，激发了 OpenHands 的创建 | ⭐⭐⭐ |
| GitHub Copilot | 上下文感知代码补全的代表，市场教育者 | ⭐⭐ |
| Anthropic (Claude) | OpenHands 使用的主要 LLM 提供商 | ⭐⭐ |
| Cursor/Continue | 本地 AI IDE 代表，与云端 Agent 对比 | ⭐⭐ |
| Redux/Zustand | React 状态管理迁移案例 | ⭐ |
| Spark 2/3 | 大数据框架迁移案例 | ⭐ |

### 💬 经典金句

> "Software development is changing... pretty much every line of code that I write goes through an agent."
> — Robert Brennan

> "The goal is not to automate this process 100%. It's something like 90% automation."
> — Robert Brennan

> "Going from writing code myself to giving that code to agents... feels like the jump from being an IC to being a manager."
> — Robert Brennan

> "We're still just in the first innings of this change."
> — Robert Brennan

### 👤 主要人物

#### Robert Brennan

**身份**：OpenHands（原 OpenDevin）联合创始人兼 CEO
**背景**：在开源开发工具领域工作超过 10 年，同时在自然语言处理领域有相同年限的经验。见证并参与了 LLM 与软件开发工具的融合进程。
**核心观点**：AI 改变软件开发的进程不应该在黑箱中发生，开发者社区应该主导这一变革。他强调即使 LLM 技术停滞，仅通过更好的操作化现有技术，软件工程在未来 2-3 年仍将发生巨变。倡导 90% 自动化 + 10% 人工审核的协作模式。

#### Calvin

**身份**：OpenHands 工程师，负责 refactor SDK 开发
**背景**：专注于大规模代码重构工具的开发，擅长将复杂的重构任务通过可视化和智能分解转化为可管理的批次。
**核心观点**：通过依赖图分析和批处理策略，可以将看似不可能的大规模重构任务（如清理 60,000 行代码的技术债务）转化为可并行执行、可人工审核的小任务。他展示了如何通过可视化工具帮助人类更好地理解和管理 Agent 编排过程。

### 📺 视频类型判断

**教程示范**：技术教学、产品演示

---

## 📝 完整翻译

### (0:00 - 5:00) 开场与 AI 编程演进历史
> 从代码片段生成到自主编程 Agent 的技术演进路径

各位好，感谢大家参加"利用并行 Agent 自动化大规模重构"的分享。今天非常激动能与大家探讨我们如何通过 Open Hands 真正自动化大规模软件工程工作。这些工作大多与技术债务、代码维护、代码现代化相关的繁重任务。这些任务完全可以自动化，你可以让 Agent 来处理它们，但它们往往过于庞大，无法通过单一的一次性操作完成。因此需要大量的 Agent 编排工作。我们今天将讨论如何通过 Open Hands 实现这一点，以及更通用的方法。

简单介绍一下我自己。我叫 Robert Brennan，是 Open Hands 的联合创始人兼 CEO。我的背景是开发工具，在开源开发工具领域工作了十多年。同时我也在自然语言处理领域工作了差不多同样长的时间。过去几年我非常兴奋地看到这两个领域突然融合，因为大语言模型在编写代码方面表现出色。我对能在这个领域工作感到非常兴奋。

Open Hands 是一个 MIT 许可的编程 Agent。Open Hands 在一年半前作为 Open Dev 项目启动，当时 Devon 首次发布了全自主软件工程 Agent 的演示视频。我和联合创始人们看到后非常兴奋，看到了可能性以及软件工程未来的样子。但我们意识到这不应该在黑盒中发生。如果我们的开发方式要改变，我们希望这种改变由软件开发社区驱动。我们希望在这种改变中有发言权。因此我们启动了 Open Dev，现在的 Open Hands，为社区提供一种方式来帮助塑造 AI 驱动世界中软件工程的未来。

说软件开发正在改变，希望这不算有争议。我知道在过去一年半里，我的工作流程发生了很大变化。我现在写的几乎每一行代码都要经过 Agent。我不再打开 IDE 逐行敲代码，而是让 Agent 为我完成工作。我仍然在做大量的批判性思考，工作的思维方式没有太大改变，但实际工作的形式已经发生了很大变化。

但我想说服大家的是，这种改变仍在继续。我们仍处于这一变化的第一阶段。我们仍未完全意识到大语言模型已经带给这个职业的所有影响，以及随着它们的改进将继续带来的影响。我认为即使今天就冻结大语言模型，不再让它们变得更好，在接下来的两到三年里，随着我们找到运营这项技术的方法，软件工程工作仍会发生非常剧烈的变化。我认为在软件工程中采用大语言模型仍存在许多心理和组织障碍，随着时间推移，我们看到很多这些障碍正在消失。

简单回顾一下我们是如何走到今天的。一切都始于我所说的上下文感知代码片段。一些最早的大语言模型在编写代码块方面表现出色，特别是那些它们反复见过的代码。你可以让它写冒泡排序算法，可以让它写小算法，比如如何访问 SQL 数据库等。它能生成小段代码，似乎理解其中的逻辑。但这完全没有上下文感知，只是在聊天窗口中输出你要求的代码，不知道你在做什么项目，不知道上下文。

紧接着我们有了上下文感知的代码生成。GitHub Copilot 作为自动补全功能可能是最好的例子。它实际上在你的 IDE 中，能看到你在哪里输入，看到你正在处理的代码，能生成特定于你代码库的代码，引用本地变量名，引用数据库中的本地表名。这对我们的生产力是巨大的改进，不再需要在 ChatGPT 窗口和 IDE 之间复制粘贴，现在小机器人有了眼睛，能看到你代码库内部，能为你的代码库生成相关代码。

### (5:00 - 10:00) Agent 编排的应用场景
> CVE 修复、代码现代化、技术债务清理等大规模重构任务

然后我认为巨大的飞跃发生在 2024 年初，Devon 发布，第二天 Open Devon（现在的 Open Hands）发布。这是我们首次开始看到自主编程 Agent。AI 不仅开始编写代码，还能运行它写的代码，能 Google 错误消息，找到 Stack Overflow 文章，将其应用到代码中，在代码中添加调试语句并运行，看看会发生什么。基本上自动化了整个开发的内循环。这是一个巨大的阶跃式前进。你可以看到图片中小机器人有了手臂。这对我的生产力来说是巨大的提升，只需写几句英文，交给 Agent，让它处理任务直到真正能工作、运行、测试通过。

现在我们看到的是并行 Agent，我们称之为 Agent 编排。人们正在研究如何让多个 Agent 并行工作，有时相互交流，有时在后台创建新的 Agent。Agent 创建 Agent。这可以说是目前可能性的前沿。人们刚开始实验这个，刚开始在大规模上看到成功，但有一些非常适合这种工作流程的任务。它有潜力真正自动化掉坐在每个现代软件公司下面的巨大技术债务山。

关于市场格局。你可以看到从左到右的同样演进，我们真正开始于像 GitHub Copilot 这样在现有 IDE 中的插件，我们有了 AI 增强的 IDE，在 IDE 上添加了 AI。我认为你的中位数开发者现在开始采用本地 Agent。他们可能在本地运行 Claude Code 来完成一两件事，可能是一些临时任务。

你的早期采用者开始关注基于云的 Agent，在云中有自己沙箱的 Agent。这允许早期采用者并行运行任意数量的 Agent。这允许他们比在本地笔记本电脑上运行更自主地运行这些 Agent。如果在本地笔记本电脑上运行，没有什么能阻止 Agent 执行 rm -rf / 试图删除你主目录中的所有内容，或者安装一些奇怪的软件。而如果它在云中有自己的容器化环境，你可以更安全地运行，知道它最多只能破坏自己的环境，你不必坐在那里看着它每次想运行命令时都按 Y 键。因此基于云的环境更具扩展性，更安全一些。

在最右边，我认为我们看到的只是前 1% 的早期采用者开始实验编排。这个想法是你不仅有这些在云中运行的 Agent，而且让它们彼此交流。你在更大的任务上协调这些 Agent。也许这些 Agent 在云中衍生出有自己沙箱环境的子 Agent。那里发生了一些非常酷的事情。

我认为用 Open Hands，我们通常从云 Agent 开始。我们稍微退了一步，构建了类似于 Claude Code 的本地 CLI，以便在开发者目前所在的地方与他们见面。这些类型的体验对开发者来说更舒适。我们使用自动补全已有几十年，只是通过 GitHub Copilot 变得好了一百万倍。我认为右侧的这些体验对开发者来说非常陌生。把控制权交给一个 Agent 或一群 Agent 让它们为你工作感觉很奇怪。对我来说至少感觉像从 IC 变成经理时的跳跃，从自己写代码变成把代码交给 Agent。因此工作方式非常不同。我认为这是开发者采用缓慢的原因之一。

但是我们看到的采用这个领域右侧内容的前 1% 左右的工程师，他们能够获得巨大的生产力提升，处理其他团队根本无法处理的巨大技术债务积压。

### (10:00 - 18:00) 编排的技术挑战与解决方案
> 上下文限制、任务分解、人机协作的最佳实践

一些你想使用编排而不是单一 Agent 的例子。通常这些是非常可重复和非常可自动化的任务。

一些例子是基本的代码维护任务。每个代码库都必须做一定量的工作来保持正常运转，保持依赖项更新，确保任何漏洞得到解决。例如，我们有一个客户正在使用 Open Hands 在整个代码库中修复 CVE。他们有数万名开发人员，成千上万的仓库。基本上每次在开源项目中宣布新漏洞时，他们必须遍历整个代码库，找出哪些仓库存在漏洞，向该代码库提交拉取请求以实际解决 CVE，更新任何依赖项，修复破坏性 API 更改。通过大规模编排，他们在这些 CVE 的时间解决方案上看到了 30 倍的改进。他们基本上现在有一个设置，每当宣布新的 CVE，新漏洞出现时，他们启动一个 Open Hands 会话来扫描仓库中的该漏洞，进行任何必要的代码更改并打开拉取请求，下游团队只需点击合并，验证更改。

你也可以用这个来自动化文档和发布说明。有很多公司面临的现代化挑战。例如，如果你使用 Python 3，你可能想给 Python 代码库添加类型注解。你可能想将 Java 单体应用拆分为微服务。这些类型的任务仍然需要工程师大量的思考。你不能只是一次性用代码说"把我的单体重构为微服务"，但这仍然是非常实际的工作，你仍然只是在复制粘贴大量代码。所以如果你深思熟虑地协调 Agent，它们可以做到这一点。

很多迁移工作。比如从旧版本的 Java 迁移到新版本的 Java。我们正在与一个客户合作，将一堆 Spark 2 任务迁移到 Spark 3。我们使用 Open Hands 将整个前端从 React Redux 迁移到 Zustand。所以你可以进行这些非常大的迁移。同样，很多繁重的工作，仍然需要人类在如何编排这些 Agent 方面进行大量思考。

还有很多技术债务，检测未使用的代码并摆脱它。我们有一个客户使用我们的 SDK 基本上每次有新的错误模式时扫描他们的数据日志，进入代码库添加错误处理，修复出现的任何问题。所以很多事情对单个 Agent 来说一次性处理太大了，但是非常可自动化，是用 Agent 处理的好任务，只要你深思熟虑地编排它们。

关于为什么这些不是一次性可停止的任务。其中一些是技术问题，一些更像是人类心理问题。在技术方面，你可以给 Agent 的上下文量有限。所以极长运行的任务或跨越非常大代码库的任务，通常你没有足够的上下文。你将不得不压缩该上下文窗口到 Agent 可能迷失的程度。我们都见过懒惰问题。我曾尝试启动一些这类任务，Agent 会说："好的，我迁移了你 100 个服务中的 3 个。我需要雇用一个六人团队来完成其余工作。"

Agent 经常缺乏你代码库内的领域知识。它们没有你对问题的同样直觉。当你与 Agent 进行这些非常长的轨迹时，错误会复合。开始时的微小错误会随时间复合。Agent 基本上会在其任务的每一步中一遍又一遍地重复该错误。

在人类方面，我们确实有对问题的直觉，但无法传达。比如说你想将单体拆分为微服务。你可能有一个关于如何工作的心理模型。如果你只是告诉 Agent "将单体拆分为微服务"，它只会基于过去见过的模式随机尝试，没有对你代码库的真正理解。

我们在为 Agent 分解任务和理解 Agent 实际能在一次性中完成什么方面有困难。我们也需要人类的中间审查，在 Agent 工作时的中间检查。我们稍后会谈论那个循环是什么样的。但这不是你可以告诉 Agent 去做并期望最终结果出现的事情。你必须在 Agent 进行时批准事情。然后没有真正的完成定义。我认为如果你真的不知道这个项目的完成是什么样子，很难告诉 Agent。

### (15:00 - 30:00) Part 2

你知道，它正在做的一切，每次想运行命令时按 Y 键。然后 Agent 完成后，你查看输出。你看到测试通过了。你看看这是否真的满足了你的要求，然后也许再次提示 Agent，让它更接近答案。或者你对结果满意了，你就提交结果并推送。

对于更大的编排任务，这变得稍微复杂一些。基本上你需要做的是，你或者与 Claude 一起，想要将你的任务分解为一系列可以由 Agent 单独执行的任务。然后你为每个单独的任务派出一个 Agent，每个单独任务都有一个这样的 Agent。最后在最后，你可能在 Agent 的帮助下，需要将所有个别 Agent 的输出拉到一起，合并成单一的变更，并将其合并到你的代码库中。

非常重要的是，这里仍然有很多人类参与循环。你需要审查的不仅仅是汇总结果的最终输出，还有每个 Agent 的中间输出。我喜欢告诉人们，目标不是 100% 自动化这个过程。而是像 90% 的自动化。这仍然是一个数量级的生产力提升。我认为这真的很难做对。这就是需要大量思考的地方，比如我将如何分解任务，这样我可以验证每个步骤，这样我实际上可以自动化整个过程，而不是最终得到一个高度耦合的混乱。

这是我喜欢用于这类任务的典型 git 工作流程。通常我们会在仓库中开始一个新分支。我们可能使用 Agent 或 Open Hand 的微 Agent 概念向该分支添加一些高级上下文。只是一个 markdown 文件，解释我们在这里做什么。这样 Agent 就知道我们正在从 Redux 迁移，或者我们要将这些 Spark 2 作业迁移到 Spark 3。你可能想要建立某种脚手架。我稍后会更多地谈论脚手架的例子。

### (18:00 - 27:00) Calvin 演示：代码异味清理案例
> 使用依赖图可视化和批处理策略消除 60,000 行代码的技术债务

你将基于第一个分支创建一堆 Agent。想法是它们将把工作提交到该分支，基本上随着我们的进展积累我们的工作，最终一旦到了最后，我们可以撕掉脚手架并将该分支合并到主分支。

现在，如果你刚开始这样做，我建议将自己限制在大约三到五个并发 Agent。我发现超过这个数量，你的大脑就开始崩溃。但对于真正大规模采用编排的人来说，我们看到他们同时运行数百甚至数千个 Agent。通常人类不在循环中，一个人类不负责审查每一个，但也许那些 Agent 正在向各个团队发送拉取请求等等。

Calvin：Open Hands 擅长解决开放性任务。给它一个专注的问题，比如修复我失败的 CI，添加并调试这个端点，它就能交付。但像所有 Agent 一样，当范围变得太大时它会stumble。假设我想重构整个代码库，也许强制执行某种更新你的依赖项，甚至从一个框架迁移到另一个框架。

这些不是任务，它们是蔓延的、相互连接的变更，可能涉及数百个文件。为了解决这种规模的问题，我们使用 Open Hands Agent SDK 构建专门设计来编排人类和多个 Agent 之间协作的工具。

作为例子，让我们努力从 Open Hands 中消除代码异味。这是仓库结构。仅核心 Agent 定义就有大约 380 个文件，跨越 60,000 行代码。这说明了代码的数量，但对结构没有太多说明。

所以让我们使用我们的新工具来可视化这个仓库块的依赖图。这里每个节点代表一个文件，边显示依赖关系——谁导入谁。当我们持续缩小时，很明显这个纠缠的网络就是大规模重构困难的原因。

为了使这可管理，我们需要将混乱分解为人性化的块。想想 PR 大小的批次，Agent 可以处理，人类可以理解。

有很多方法可以基于对你重要的东西进行批处理。图论算法对诱导批次之间的边结构给出强有力的保证，但为了我们的目的，我们可以简单地使用现有的目录结构来确保语义相关的文件出现在同一批次内。导航回依赖图，我们可以看到节点的代码不再随机分布。相反，它们对应于每个关联文件存在的批次。

放大和缩小，我们很容易找到一个相邻节点的集群，它们都是相同的颜色，这表明 Agent 将同时访问所有这些文件。

当然，这个图仍然很大且非常纠缠。为了构建一个更简单的视图，我们将构建一个新图，其中节点是批次，这些节点之间的边是从每个批次内文件继承的依赖关系。这个视图更简单。我们可以同时在屏幕上看到整个结构。

但这是我们使用图的好处。我们可以识别没有依赖项的批次。例如，dispatch 添加 16，看起来它在文件中，可能是空的。让我们检查一下。

现在，这是一个用于人类 AI 协作的工具。所以，一旦我们知道这个文件是空的，我们可能决定最好将它移到别处。或者也许我们可以将它保留在这个批次中。我们所想做的就是给自己添加一个注释，这样我们就知道内容了。

当然，在重构代码时，考虑你要移动的内容的复杂性很重要。这个批次是微不足道的。让我们找一个稍微复杂一点的。这是一个有四个文件的批次。它们都做，复杂性度量反映了这一点。这些有助于向人类表明我们在这种情况下应该更加小心。

你需要首先识别问题所在。进入验证器。有几种不同的方法来定义验证器，基于你关心的内容。你可以认为它是程序化的。所以它调用一个匹配命令。如果你的验证是检查单元测试或运行 linter 或文本，这很有用。

但是，因为我对代码异味感兴趣，我将使用一个语言模型，它将查看代码并尝试基于我提供的一组规则识别任何有问题的模式。

现在，让我们回到我们的第一个批次并实际使用这个验证器。记住，这个批次是微不足道的，幸运的是验证器认识到了这一点。

### (27:00 - 34:00) 任务分解与上下文共享策略
> 并行 Agent 如何高效协作和知识传递

它返回一个很好的小报告，指示哪个人被识别了，哪个没有。这个批次的状态变为完成绿色。好的。

状态的这种变化也反映在批次图中。导航回去并切换颜色显示，我们可以看到在许多批次中我们有一个完成的节点，其余的仍然有待处理。但这已经给了我们对我们已完成工作的非常好的感觉，以及它如何适应更大的图景。

所以现在我们确保仓库中没有代码异味的策略很简单。我们只需确保这个批次图上的每个节点都变绿。

所以让我们回到我们的批次并继续验证，直到我们遇到失败。我们将继续按依赖关系进行，确保我们选择对我们尚未分析的其他批次没有任何依赖关系的节点。

下一个批次和第一个一样简单，但因为 init 文件稍微复杂一些，生成的报告稍微详细一些。继续下去，我们遇到了我们之前识别的具有一些大文件和相对较高代码复杂性的批次。这个批次恰好给了我们第一个故障。注意状态变为红色而不是绿色。

现在这个批次比我们过去看到的文件更多。所以验证报告相应地更长。看着看到它按文件列出，识别的代码中，我看到一个文件的违规特别严重。我们必须回到那里。

### (30:00 - 45:00) Part 3

然后在最后，一旦你迁移了每个文件，你就可以将所有这些结果收集到一个 PR 中。

一个稍微复杂一些的方法是创建依赖树。这里的想法是在逐步迁移的方法中增加一些排序，就像我们看到 Calvin 所做的那样，你从依赖关系图中的叶节点开始，也就是从工具文件开始迁移，然后任何依赖于这些文件的代码都会有这些初始修复，依赖关系就可以开始处理它们的流程。你基本上可以反向推进到应用程序的入口点。这通常是一个更好的方法，是对如何排序这些任务的更原则性的方法。

另一个例子是创建某种脚手架，让你能够同时存在于迁移前和迁移后的两个世界中。比如，当我们迁移 React 状态管理系统时就是这样做的。我们基本上让 agent 设置了一些脚手架，允许我们同时使用 Redux 和 Zustand。这很丑陋，实际上不是你真正想要做的事情。但它允许我们在每个组件从旧的状态管理系统迁移到新的状态管理系统时测试应用程序。然后我们为每个组件派遣了并行的 agent。

每个组件都完成后，在最后一切都使用 Zustand 时，我们能够撤除所有脚手架，不再提及 Redux，一切都在工作。但拥有这个脚手架允许我们验证，当每个 agent 完成其仅针对一个组件的工作时，我们可以验证应用程序仍在工作，该组件仍然工作。我们不必一次完成所有事情，我们从 agent 那里得到了一些人工反馈。

接下来我想谈一下上下文共享。当你处理这样的大规模项目时，你会学到很多东西。你会发现，我的原始心理模型实际上并不完整，我实际上没有正确理解问题。你的 agent 可能会遇到这种情况，你可能有一群 agent，比如 10 个 agent 在运行，它们都遇到了完全相同的问题，你希望分享该问题的解决方案，这样它们就不会都卡在那里。

有一bunch不同的策略来实现 agent 之间的上下文共享。

我认为最简单的策略是分享一切。基本上，每个 agent 都能看到其他每个 agent 的上下文。这不太好，基本上和让单个 agent 逐步处理任务是一样的。如果你这样做，你会很快耗尽上下文窗口。所以这不会有帮助。

一个更好的方法是让人类手动向 agent 输入信息。如果你与每个 agent 有聊天窗口，你可以直接粘贴"使用库 1.2.3 而不是 1.2.2"。人类也可以修改 agent.md 或微 agent 来向这些 agent 传递消息。但这确实涉及手动人工努力，涉及更多对 agent 的照料，所以不太可扩展。

### (34:00 - 45:00) 实战演练：环境搭建
> 配置 GitHub、OpenHands SDK 和 Agent 服务器

你也可以让 agent 基本上通过文件如 agent.md 相互分享上下文。你可以允许 agent 自己实际修改这个文件。也许它们在学到新东西时向文件发送 pull request。这里的缺点是有时 agent 会试图学习不重要的事情。它们可能会对向这个文件推送信息变得激进。所以进行某种人工审查似乎会有帮助。

最后，这可能是这里最前沿的想法。但你基本上可以给每个 agent 一个工具，允许它向其他 agent 发送消息。这可能是向所有其他 agent 发送的广播消息，或者可能是点对点对话。这实验起来非常有趣。我们现在用我们的 SDK 做了很多这方面的实验。但让它正确运行很棘手。

一旦你让 agent 彼此对话，你就增加了系统中的非确定性水平。事情可能会变得有点混乱。我在右边有个例子，这来自一个医生报告，他们让两个 agent 彼此对话。它们只是进入了一个互相祝愿禅宗完美的循环中。

好的，现在我想进行一个练习。如果你们都想跟着做，我会很高兴。你可以在 dev.shophands-workshop 访问这个演示文稿用于复制粘贴。我们将使用 Open Hands SDK 进行一些编码练习，专门用于大规模 CVE 修复。我们将编写一个脚本，它将接收一个 GitHub 仓库，扫描开源漏洞或 CVE，然后为我们找到的每个漏洞设置并行 agent 来解决它并开启 pull request。

所以，dev.shophands-workshop。让我知道是否有人可以访问它。

**观众**：会是幻灯片吗？

**讲者**：应该是幻灯片，如果你想的话。大约在第 29 页会有可复制粘贴的提示和链接等。

**观众**：明白了。

**讲者**：我们会到那里的。

就这个流程如何工作而言，基本上我们将从一个 agent 开始，在这个仓库上运行 CVE 扫描。它将查找漏洞。使用 agent 的好处是它可以查看仓库并决定我将如何扫描漏洞，对吧？我是要使用 trivy 扫描 Docker 镜像吗？还是在 package.json 上运行 npm audit？

所以它基本上可以检测编程语言来确定我将如何在这里扫描 CVE。然后一旦我们有了漏洞列表，我们将为每个漏洞运行单独的 agent。每个 agent 都将研究它是否可解决，更新相关依赖项，修复整个代码库中任何破坏性的 API 更改，然后开启 pull request。这样做的好处是我们可以在这些单独的 PR 准备好后合并它们。

**观众**：再显示一下链接。

**讲者**：并行解决的好处是我们得到了一bunch不同的 PR。所以我们可以在它们准备好时合并它们。如果一个 agent 卡住了，一个漏洞无法解决，其他所有的仍然会工作。也许我们解决了 90% 或 95%。我们不必达到 100% 就能有任何价值。这里有一些这将是什么样子的快速伪代码。

这是使用 OpenHands SDK 如何创建 agent 的示例。你可以看到我们创建了一个大语言模型，然后我们将该大语言模型连同一些工具传递给 agent 对象。终端、文件所有者、用于规划的传递跟踪器。我们给它一个工作空间，然后我们只是告诉它我们想要运行。这是一个相当简单的 hello world 示例。随着我们在这个特定任务中的进展，我们会看到它如何变得更复杂一些。

但然后一旦第一个 agent 完成，我们将遍历它返回的所有漏洞。然后对于每一个，我们将派遣一个新的 agent，要求它解决那个特定的 CVE。

好的，所以为了开始，你需要创建一个新的 GitHub 仓库。我们将在那里保存我们的工作。你还需要 GitHub token 和 LLM token。

如果你注册 app.allhands.dev，你可以在那里获得 10 美元的免费 LLM 积分。如果你已经是现有用户，请告诉我，我可以为这个练习的目的增加你的现有积分。

然后我们将启动一个 agent 服务器。这基本上是一个 Docker 容器，将容纳我们的 agent 正在做的所有工作。这再次是安全且更可扩展地运行 agent 的好方法。所以我们不是在本地机器上运行 agent 来解决所有这些 CVE，而是在容器内运行它们。假设如果我们处理数千个 CVE，我们可以在 Kubernetes 集群中运行它，这样我们就有了尽可能多的工作站供我们的 agent 使用。但为了这个练习的目的，我们只是运行一个 Docker 容器作为我们 agent 的家。

然后我们可以创建一个 agent，或者一个 OpenHands 微 agent 来开始处理这个任务。我将使用 OpenHands CLI。你们也欢迎查看 OpenHands CLI。你也可以使用 Cursor 或 VS Code 或任何你习惯使用的工具，当我们通过 OpenHands 进行 CVE 修复过程时。

我会给几分钟时间。我将演示创建 GitHub 仓库、获取 GitHub token 等。如果你们有任何问题，请举手，我会来帮助你们解决。

**观众**：你说的是 app.allhands.dev？

**讲者**：是的。

所以我有了我的新 GitHub 仓库。我要在这里添加一个快速的 OpenHands 微 agent。完美。我只是要告诉它一个用 agent 进行修复的过程。OpenHands SDK 的相关文档在 OpenHands SDK。所以提供一些上下文，类似于 agent。我们现在有官方的获取 token 的方法。我实际上不会在这里展示，因为那是我的 token，但你可以去 GitHub 设置，你的个人资料，然后开发者设置，个人访问 token。我喜欢用经典 token。经典 token，给它一个名字，然后仓库范围是你真正需要的。这样我们就可以开启 pull request 来解决涉及的 CVE。

**观众**：我们用经典 token 而不是新的？

**讲者**：我还没有习惯新的，你们欢迎使用。我猜你可以创建新仓库。

**观众**：我也还没习惯新的。

**讲者**：回到旧时光。

**观众**：我们需要什么权限？只是仓库权限？

**讲者**：是的，只是仓库权限。另外，请注册 app.allhands.dev。你去个人资料下的设置，你可以在这里获得你的 OpenAI 密钥，你的 L 密钥。我不会显示它，但这将允许你使用我们的代理服务。

最后，我将在这里启动一些 agent 服务器。你可能想从演示文稿中复制粘贴这个。

### (45:00 - 1:00:00) Part 4

### (45:00 - 1:00:00) CVE 扫描 Agent 实现
> 创建自动扫描仓库漏洞的智能 Agent

我将启动 OpenHands CLI。同样，如果你愿意，可以使用 Cloud Code、Cursor 或其他工具。看起来大家需要更多时间来设置密钥获取令牌。

抱歉，让我检查一下。我将从第一个提示开始。基本上我们要做的是将我们的 agent 指向 OpenHands SDK，指向文档，然后要求它基本检查我们的 LLM API 密钥是否正常工作，是否能够真正进行 LLM 调用。这将是一个非常基础的 Hello World，让我们开始上手。

我要告诉它我正在使用在 app.allhands.dev 生成的 OpenHands 密钥。我告诉它使用这个 OpenHands Claude 4 模型。如果你想使用常规的 Anthropic API 密钥，可以将其替换为 Anthropic。根据你使用的是 OpenAI 还是 Litellm，你可能需要稍微不同地设置这个模型。

如果你有 OpenAI API 密钥，可以查看 Litellm 文档来确定应该使用哪个模型字符串。但我只是要按原样复制粘贴这个。

**观众**：agents.md 的步骤是什么，还是 OpenHands 的步骤？

**讲者**：我建议创建一个文件，如果你使用的工具兼容的话就创建 agents.md，或者对于 OpenHands，我们有一个叫做 micro agent 的东西。按照惯例，repo.md 是你所在仓库的描述。我给了它几个指向 SDK 文档的链接，以及 SDK 仓库的链接，这样它就可以访问基本的 API 文档。这是一个可选步骤，但会让事情变得更容易一些。

好的，它认为自己找到了好的解决方案。让我们看看发生了什么。

Python 环境解析器需要环境变量。我使用它来设置我的密钥，确保我不会将这些检查进去。

再试一次。遇到了一个小错误。看起来 agent 没有完全正确理解 API 文档。让我们将错误粘贴回去，看看会发生什么。

让我们再试一次。当然，永远不会... 没有。它在工作。

**观众**：我们用 UV 吧。

**讲者**：UV 工具安装失败了。

**观众**：是的。你知道你用的是什么版本的 UV 吗？

**讲者**：我用的是 0.9.6。

**观众**：你遇到了什么错误？

**讲者**：不知道为什么。包 OpenHands 没有提供可执行文件。移除工具错误，无法安装入口点。

**观众**：我对 Python 世界比较新，所以我以为我做了什么蠢事。

**讲者**：你可以尝试更新到 1.1.1，那是我正在使用的版本。好的，我会试试。

**观众**：另一个问题。

**讲者**：是的？

**观众**：我能够... 我看到你在 CLI 中运行。我能够在 allhands.dev 上运行这个。

**讲者**：是的，很酷。它提交了一个 PR 并创建了它。看起来不错。

**观众**：太棒了。

**观众**：你为什么要通过 CLI 来做这件事？

**讲者**：实际上真的只是为了... 通常我实际上更喜欢通过这里的 Web UI 工作。我认为能够运行并展示脚本在本地工作，这样的演示效果会更好一点。我通常喜欢通过 Web UI 工作，然后让 agent 推送，如果我真的想在本地工作的话，我就在本地拉取，但我觉得那样对于演示目的来说是额外的步骤。

是的，可以随意使用 Web 或工具。

看起来我... 这里是 API 密钥。天啊。200。

**观众**：那是什么？

**观众**：我们应该得到 200 吗？

**讲者**：是的，你应该得到类似这样的东西。就像我刚刚最终得到的，另一个显示 hello 的地方。

有人成功建立连接了吗？

**观众**：我想是的。我已经创建了文件。

**讲者**：很好。

这是第一部分的快速概览，基本上你可以看到我们创建了一个，告诉它我们想使用什么模型，我们想使用什么密钥，然后只是发送一个快速消息来确保它确实在工作。

好的，第二次我将转向提示二。这里我们实际上要开始为... 做一些工作，所以我们要告诉 agent 我们正在使用 SDK 创建一个新的 agent，它将接收一个 GitHub 仓库。它将连接到运行在 localhost 8000 的远程工作空间。同样，那是之前的 Docker 启动命令。如果你还没有运行它，现在是启动 Docker 的好时机。Docker 运行这个 agent 服务器。

它将把我们的仓库克隆到那个 Docker 容器中。我们将创建一个在该 Docker 容器内工作的 agent，我们将告诉该 agent 扫描这个仓库寻找任何... 使用 OpenHands CLI。有没有办法中断并让它停止？

**观众**：按 Control P 或暂停。

**讲者**：然后我可以插入我的修正吗？

**观众**：是的。然后你可以给我发消息或者直接输入继续。

**观众**：我成功安装了 CLI，但我必须添加 -AI。

**观众**：看起来在 PyPI 上有一个带 AI 的版本，但文档中说...

**讲者**：我不... 我认为 AI 版本已被弃用，但它确实是一个可用的 CLI。你想使用我们团队提供的服务。

你成功让 dash AI 版本工作了吗？因为我一试图运行它，它就崩溃了。

**观众**：哦，糟糕。它安装了。我很高兴。

**讲者**：是的，它安装了，然后就不工作了。

**观众**：当我查看版本时有弃用警告。所以，是的。

**讲者**：如果你想下载可执行二进制文件，我们的发布页面上有。

**观众**：好的。

**讲者**：那可能更直接。你也可以在 Docker 容器中运行它。如果你查看 CLI 文档，我认为也有 UV run。试试 UV run。

版本... 那是针对非 OpenAI 常规版本的。

**观众**：好的，谢谢。

**讲者**：好的，据说这里有一个 agent 在工作。让我们看看。我要用仓库运行它。它应该有一些 CVE。让我们看看是否能找到任何漏洞。

默认情况下，OpenHands 会可视化输出。所以，我们可以看到 agent 在工作，即使使用 SDK 也很类似于我们看到的 CLI。

### (1:00:00 - 1:15:00) Part 5

### (1:00:00 - 1:16:00) 并行修复 Agent 部署
> 为每个漏洞创建独立 Agent 并行修复

你可以看到它的任务列表。它正在处理仓库。它本身没有漏洞检测功能，所以它就像 Trivy 一样，基本上在做我们期望 agent 做的事情。我们给了它一个任务，现在无法访问它，所以我们正在运行 Trivy。

让我展示一下这些生成的代码是什么样的。你可以看到我们在第一步实例化了我们的 LLM。

现在我们实际上将这个 LLM 传递给一个 agent。我们还给它提供了终端工具和文件编辑器工具。我们创建了这个远程工作空间，连接到我们的 Docker 容器，这样 agent 就可以在自己的环境中开始工作。我们创建了一个叫做对话的东西，基本上是 agent 在工作过程中要管理的一块上下文。我们给它传递一个任务，明确指示它应该做什么，然后发送这个任务。

看起来初始扫描器 agent 快完成了。

看起来那个 agent 运行得很好，得到了这些结果。

我会继续推进。我们有一个正在扫描漏洞的 agent。

接下来我要让它做的基本上是我们要深入环境并从中获取漏洞列表。想法是我们要让它将漏洞保存到一个 JSON 文件中。然后在 Docker 容器内的工作空间对象上，我们可以运行执行命令来获取这些漏洞。我们还有一些在工作空间内操作文件的选项。现在我们只是要遍历 vulnerabilities.json 文件，打印出来，这样我们就能看到我们能够深入工作空间并获取一些信息。

好的，应该准备就绪了。看看会发生什么。

很好，得到了一些漏洞结果。Agent 完成了。让我们看看我们的脚本能否获取到结果。

**观众**：什么是观察事件？对于每个状态都有一个动作然后一个观察。所以可能是运行这个命令，然后观察返回那个命令的输出。

**讲者**：这不仅仅是一个，这基本上是 agent 采取的整个轨迹，包括事件，然后有两种事件：动作和观察。所以每当我们调用 LLM 时，它会返回一个要采取的动作或基本上是一个工具调用，然后观察就像是一个工具调用的结果。

如果有人在任何地方遇到困难，很乐意过来帮忙，可以随时举手。

很好，看起来它正在打印 CVE 列表。看起来不错。

**观众**：为什么要为我们运行的每个脚本创建一个特定的子 agent？为什么要一遍又一遍地重写同一个文件？

**讲者**：我们在这里通过这五个提示进行的过程实际上是为了演示使用我们的 SDK 构建时的感觉。这不是我会采用的方式，这是我在积极解决问题时可能会使用的方式。我本可以给你这个完全打包的、预构建的完整代码库。

但这样我们就拥有了所有这些构建的内容。这是你问的吗？比如我们为什么要一个一个地粘贴这些提示？

**观众**：最终我们会得到一个非常大的脚本，我们应该将它分解成几个单独的文件或部分。

**讲者**：是的，我认为肯定有更好的方法来组织这些代码，而不是只有一个单一脚本。为了演示目的这样更容易。是的，我确实有一个演示仓库，我想是 openhand CVE demo，它使用特殊的类。有一个单一的 CVE agent 子类，比这个单一脚本要复杂一些。

我们仍在处理 JSON。

很好，这是一个很好的问题。

关于开源模型。

### (1:15:00 - End) Part 6

我实际上不知道我将会做什么。

好吧，问题是...我的意思是...

主持人：是的，这很热门。


---

*生成时间: 2026-01-09 03:03:39*
*由 YouTube Monitor & Translator (Claude CLI) 生成*